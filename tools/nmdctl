#!/bin/bash
#
# nmdctl - NonRAID array management utility
#

# Colors for pretty output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default superblock path
DEFAULT_SUPERBLOCK="/nonraid.dat"
SUPERBLOCK_PATH=""

# Display usage information
usage() {
    echo "nmdctl - NonRAID array management utility"
    echo ""
    echo "Usage: nmdctl [GLOBAL OPTIONS] COMMAND [COMMAND OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  status                      Show current array status"
    echo "  create                      Create a new array with interactive disk assignment"
    echo "  start                       Start the array"
    echo "  stop                        Stop the array"
    echo "  import                      Import all disks to the array without starting it"
    echo "  add                         Add a new disk to the array interactively"
    echo "  unassign SLOT               Unassign a disk from the specified slot"
    echo "  reload                      Reload nonraid module with specified superblock"
    echo "  check                       Start parity check"
    echo "  nocheck [CANCEL|PAUSE]      Stop parity check (CANCEL or PAUSE)"
    echo ""
    echo "Global Options:"
    echo "  -s, --super PATH            Superblock file path to use when loading the module (default: $DEFAULT_SUPERBLOCK)"
    echo "  -h, --help                  Display this help message"
    echo ""
    exit 1
}

# Check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}Error: This command must be run as root${NC}"
        exit 1
    fi
}

# Run a command via nmdcmd
run_nmd_command() {
    check_root
    echo "$1" > /proc/nmdcmd
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to run command '$1'${NC}"
        return 1
    fi
    return 0
}

# Check if the nonraid module is loaded, and load it if superblock is provided
check_module_loaded() {
    local superblock="${SUPERBLOCK_PATH:-$DEFAULT_SUPERBLOCK}"
    local is_create_command=0

    # Check if we're being called as part of the create command
    local call_stack="${FUNCNAME[@]}"
    if [[ "$call_stack" == *"create_array"* ]]; then
        is_create_command=1
    fi

    # Check if module is already loaded
    if lsmod | grep -q nonraid; then
        # For create_array, verify the module is using the correct superblock
        if [ "$is_create_command" -eq 1 ] && [ -f /proc/nmdstat ]; then
            local current_superblock=$(get_nmdstat_value "sbName")

            # If the current superblock doesn't match what we want to use
            if [ "$current_superblock" != "$superblock" ] && [ -n "$current_superblock" ] && [ "$current_superblock" != "(null)" ]; then
                echo -e "${RED}Error: NonRAID module is loaded with a different superblock${NC}"
                echo -e "Currently loaded with: ${YELLOW}$current_superblock${NC}"
                echo -e "Attempting to create array with: ${YELLOW}$superblock${NC}"
                echo -e ""
                echo -e "This could accidentally modify the wrong superblock file."
                echo -e "Please unload the module first with: ${YELLOW}modprobe -r nonraid${NC}"
                echo -e "Or use: ${YELLOW}nmdctl --super $superblock reload${NC}"
                return 1
            fi
        fi

        return 0
    fi

    # Module not loaded, attempt to load it
    # For create command, we can accept non-existent superblock files
    if [ -f "$superblock" ] || [ "$is_create_command" -eq 1 ]; then
        echo -e "${YELLOW}NonRAID module not loaded, attempting to load with superblock: $superblock${NC}"

        # For create command with new superblock, provide info
        if [ ! -f "$superblock" ] && [ "$is_create_command" -eq 1 ]; then
            echo -e "${YELLOW}Note: Superblock file '$superblock' doesn't exist yet${NC}"
            echo -e "${YELLOW}A new superblock will be created when the array is started${NC}"
        fi

        modprobe nonraid super="$superblock"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to load nonraid module${NC}"
            return 1
        fi
        echo -e "${GREEN}Successfully loaded nonraid module${NC}"
        return 0
    else
        echo -e "${RED}Error: nonraid module is not loaded${NC}"
        echo -e "Superblock file not found: $superblock"
        echo -e "Please load the module with: ${YELLOW}modprobe nonraid super=/path/to/superblock.dat${NC}"
        echo -e "Or specify superblock with: ${YELLOW}nmdctl --super /path/to/superblock.dat ...${NC}"
        return 1
    fi
}

# Check if /proc/nmdstat exists
check_nmdstat_exists() {
    if [ ! -f /proc/nmdstat ]; then
        # Try to load the module first if it's not loaded
        if ! lsmod | grep -q nonraid; then
            check_module_loaded
        fi

        # Check again after attempted load
        if [ ! -f /proc/nmdstat ]; then
            echo -e "${RED}Error: /proc/nmdstat not found${NC}"
            echo -e "Please ensure the nonraid module is properly loaded"
            return 1
        fi
    fi
    return 0
}

# Get value from nmdstat
get_nmdstat_value() {
    grep -E "^$1=" /proc/nmdstat | cut -d= -f2
}

# Format disk status with color - returns colored text with consistent visible width
format_disk_status() {
    local status="$1"
    case "$status" in
        "DISK_OK")
            echo -e "${GREEN}OK${NC}"
            ;;
        "DISK_INVALID")
            echo -e "${RED}INVALID${NC}"
            ;;
        "DISK_NP_MISSING")
            echo -e "${YELLOW}MISSING${NC}"
            ;;
        "DISK_WRONG")
            echo -e "${RED}WRONG${NC}"
            ;;
        "DISK_DSBL"|"DISK_NP_DSBL"|"DISK_DSBL_NEW")
            echo -e "${YELLOW}DISABLED${NC}"
            ;;
        "DISK_NEW")
            echo -e "${BLUE}NEW${NC}"
            ;;
        *)
            echo -e "${YELLOW}$status${NC}"
            ;;
    esac
}

# Format array state with color
format_array_state() {
    local state="$1"
    case "$state" in
        "STARTED")
            echo -e "${GREEN}$state${NC}"
            ;;
        "STOPPED")
            echo -e "${YELLOW}$state${NC}"
            ;;
        "NEW_ARRAY")
            echo -e "${BLUE}$state${NC}"
            ;;
        "RECON_DISK"|"DISABLE_DISK"|"SWAP_DSBL")
            echo -e "${YELLOW}$state${NC}"
            ;;
        "ERROR:"*)
            echo -e "${RED}$state${NC}"
            ;;
        *)
            echo "$state"
            ;;
    esac
}

# Get count of defined disk slots in the array
# Returns the count of all slots with a defined disk
get_defined_slots_count() {
    # We check for non-empty diskId values
    grep -c -E "^diskId\.[0-9]+=[^=]+" /proc/nmdstat
}

# Get array of defined slot numbers
# Returns space-separated list of slot numbers that have disks defined
get_defined_slots() {
    # Extract just the slot numbers for slots with defined disks
    grep -E "^diskId\.[0-9]+=[^=]+" /proc/nmdstat | cut -d'.' -f2 | cut -d'=' -f1
}

# Format time duration in seconds to a human-readable format (HH:MM:SS)
format_time_duration() {
    local seconds=$1
    local hours=$(( seconds / 3600 ))
    local minutes=$(( (seconds % 3600) / 60 ))
    local secs=$(( seconds % 60 ))

    if [ "$hours" -gt 0 ]; then
        printf "%d:%02d:%02d" "$hours" "$minutes" "$secs"
    elif [ "$minutes" -gt 0 ]; then
        printf "%d:%02d" "$minutes" "$secs"
    else
        printf "%d sec" "$secs"
    fi
}

# Show current array status
show_status() {
    if ! check_nmdstat_exists; then
        return 1
    fi

    echo "=== NonRAID Array Status ==="
    echo ""

    # Get basic array info
    local mdstate=$(get_nmdstat_value "mdState")
    local sblabel=$(get_nmdstat_value "sbLabel")
    local sbname=$(get_nmdstat_value "sbName")
    local mdnumdisks=$(get_nmdstat_value "mdNumDisks")
    local mdnummissing=$(get_nmdstat_value "mdNumMissing")
    local mdnuminvalid=$(get_nmdstat_value "mdNumInvalid")

    # Get additional health indicators
    local mdnumwrong=$(get_nmdstat_value "mdNumWrong")
    local mdnumdisabled=$(get_nmdstat_value "mdNumDisabled")
    local mdnumreplaced=$(get_nmdstat_value "mdNumReplaced")
    local mdnumnew=$(get_nmdstat_value "mdNumNew")

    # Display array summary
    echo -e "Array State   : $(format_array_state "$mdstate")"
    [ -n "$sblabel" ] && echo -e "Array Label   : $sblabel"

    # Check if superblock is valid
    if [ "$sbname" = "(null)" ]; then
        echo -e "Superblock    : ${RED}INVALID${NC}"
        echo -e "${YELLOW}Warning: Module loaded without specifying superblock.${NC}"
        echo -e "${YELLOW}Use '${GREEN}nmdctl --super /path/to/superblock.dat reload${YELLOW}' to reload with valid superblock.${NC}"
    else
        echo -e "Superblock    : $sbname"
    fi

    echo -e "Disks Present : $mdnumdisks"

    # Check array health status based on various conditions
    local health_status=""
    local health_details=""

    # Count the total number of disk slots that are defined in the array
    local total_slots=$(get_defined_slots_count)

    # Count how many disks have been imported
    local imported_disks=0
    for slot in $(get_defined_slots); do
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            imported_disks=$((imported_disks + 1))
        fi
    done

    # Check for critical error conditions first
    if [ "$mdstate" = "ERROR:"* ]; then
        health_status="${RED}ERROR${NC}"
        health_details="Array is in ERROR state"
    # Check if this is a new array
    elif [ "$mdstate" = "NEW_ARRAY" ]; then
        health_status="${BLUE}NEW${NC}"
        health_details="New array, parity needs to be built"
    # Check if a new disk is added (driver only supports one new disk at a time)
    elif [ -n "$mdnumnew" ] && [ "$mdnumnew" -gt 0 ]; then
        health_status="${BLUE}NEW_DISK${NC}"
        health_details="New disk added to the array"
    # Check if no disks have been imported yet
    elif [ "$imported_disks" -eq 0 ] && [ "$total_slots" -gt 0 ]; then
        health_status="${RED}OFFLINE${NC}"
        health_details="No disks imported"
    # Check if not all disks are imported
    elif [ "$imported_disks" -lt "$total_slots" ]; then
        health_status="${YELLOW}PARTIAL${NC}"
        health_details="$imported_disks/$total_slots disks imported"
    # Check for standard degraded conditions
    elif [ "$mdnummissing" -gt 0 ] || [ "$mdnuminvalid" -gt 0 ] ||
         [ "$mdnumwrong" -gt 0 ] || [ "$mdnumdisabled" -gt 0 ] ||
         [ "$mdnumreplaced" -gt 0 ]; then
        health_status="${YELLOW}DEGRADED${NC}"

        local issues=""
        [ "$mdnummissing" -gt 0 ] && issues="${issues}Missing: $mdnummissing, "
        [ "$mdnuminvalid" -gt 0 ] && issues="${issues}Invalid: $mdnuminvalid, "
        [ "$mdnumwrong" -gt 0 ] && issues="${issues}Wrong: $mdnumwrong, "
        [ "$mdnumdisabled" -gt 0 ] && issues="${issues}Disabled: $mdnumdisabled, "
        [ "$mdnumreplaced" -gt 0 ] && issues="${issues}Replaced: $mdnumreplaced, "
        # Remove trailing comma and space
        health_details=${issues%, }
    # Check if array is stopped but healthy
    elif [ "$mdstate" = "STOPPED" ]; then
        health_status="${YELLOW}READY${NC}"
        health_details="All disks imported but array is not started"
    # Everything is good!
    else
        health_status="${GREEN}HEALTHY${NC}"
        health_details="All disks present and functioning"
    fi

    # Display the health status
    echo -n -e "Array Health  : $health_status"
    if [ -n "$health_details" ]; then
        echo -e " ($health_details)"
    else
        echo ""
    fi

    # Calculate array size and parity information
    local has_parity=false
    local has_second_parity=false
    local data_size_gb=0
    local parity_size_gb=0
    local second_parity_size_gb=0

    # Check slots 0 and 29 for parity disks
    local parity_disk_size=$(get_nmdstat_value "diskSize.0")
    if [ -n "$parity_disk_size" ] && [ "$parity_disk_size" -gt 0 ]; then
        has_parity=true
        parity_size_gb=$(( (parity_disk_size + 1048575) / 1048576 ))
    fi

    # Check P state
    local parity_disk_status=$(get_nmdstat_value "rdevStatus.0")
    if [[ "$parity_disk_status" == DISK_NP* ]] || [ "$parity_disk_status" = "DISK_DSBL_NEW" ] || [ "$parity_disk_status" = "DISK_INVALID" ]; then
        # P missing or new, don't count it yet
        has_parity=false
    fi

    local second_parity_disk_size=$(get_nmdstat_value "diskSize.29")
    if [ -n "$second_parity_disk_size" ] && [ "$second_parity_disk_size" -gt 0 ]; then
        has_second_parity=true
        second_parity_size_gb=$(( (second_parity_disk_size + 1048575) / 1048576 ))
    fi

    # Check Q state
    local second_parity_disk_status=$(get_nmdstat_value "rdevStatus.29")
    if [[ "$second_parity_disk_status" == DISK_NP* ]] || [ "$second_parity_disk_status" = "DISK_DSBL_NEW" ] || [ "$second_parity_disk_status" = "DISK_INVALID" ]; then
        # Q missing or new, don't count it yet
        has_second_parity=false
    fi

    # Count data disks and sum their sizes
    local data_disk_count=0
    for slot in $(seq 1 28); do
        local disk_size=$(get_nmdstat_value "diskSize.$slot")
        if [ -n "$disk_size" ] && [ "$disk_size" -gt 0 ]; then
            data_disk_count=$((data_disk_count + 1))
            data_size_gb=$((data_size_gb + (disk_size + 1048575) / 1048576))
        fi
    done

    # Display array size information
    echo -e "Array Size    : ${data_size_gb} GB (${data_disk_count} data disk(s))"

    # Display parity protection information
    echo -n "Parity        : "
    if $has_parity && $has_second_parity; then
        echo -e "${GREEN}Dual Parity${NC} (P: ${parity_size_gb} GB, Q: ${second_parity_size_gb} GB)"
    elif $has_parity; then
        echo -e "${GREEN}Single Parity${NC} (${parity_size_gb} GB)"
    else
        echo -e "${YELLOW}No Parity${NC}"
    fi

    # Check for reconstruction or check operations
    local mdresync=$(get_nmdstat_value "mdResync")
    local mdresyncaction=$(get_nmdstat_value "mdResyncAction")

    # Check for pending disk clearing
    if [ "$mdresync" = "0" ] && [ "$mdresyncaction" = "clear" ]; then
        echo ""
        echo -e "${YELLOW}Disk clearing pending: New disk needs to be cleared${NC}"
        echo -e "${YELLOW}Start the array and use '${GREEN}nmdctl check${YELLOW}' command to start the disk clear${NC}"
    # Check for pending reconstruction
    elif [ "$mdresync" = "0" ] && [[ "$mdresyncaction" == recon* ]]; then
        echo ""
        echo -e "${YELLOW}Disk reconstruction pending: ${BLUE}$mdresyncaction${NC}"
        echo -e "${YELLOW}Start the array and use '${GREEN}nmdctl check${YELLOW}' command to start the reconstruction${NC}"
    # Check for active reconstruction or check operation
    elif [ "$mdresync" != "0" ] && [ -n "$mdresync" ]; then
        local mdresyncpos=$(get_nmdstat_value "mdResyncPos")
        local mdresyncsize=$(get_nmdstat_value "mdResyncSize")
        local mdresyncdt=$(get_nmdstat_value "mdResyncDt")
        local mdresyncdb=$(get_nmdstat_value "mdResyncDb")

        # Calculate progress percentage
        local progress=0
        if [ "$mdresyncsize" -gt 0 ]; then
            progress=$(( mdresyncpos * 100 / mdresyncsize ))
        fi

        # Calculate rate (blocks per second)
        local rate=0
        if [ "$mdresyncdt" -gt 0 ]; then
            rate=$(( mdresyncdb / mdresyncdt ))
        fi

        # Convert rate from KB/s to MB/s (using bash arithmetic for compatibility)
        local rate_mb_int=$(( rate * 100 / 1024 ))
        local rate_mb_whole=$(( rate_mb_int / 100 ))
        local rate_mb_frac=$(( rate_mb_int % 100 ))
        local rate_mb="${rate_mb_whole}.$(printf "%02d" $rate_mb_frac)"

        # Calculate elapsed time (mdResyncDt is in seconds)
        local elapsed_time=$mdresyncdt
        local elapsed_formatted=$(format_time_duration $elapsed_time)

        # Calculate estimated time remaining
        local eta_seconds=0
        if [ "$rate" -gt 0 ] && [ "$mdresyncsize" -gt "$mdresyncpos" ]; then
            local remaining_blocks=$(( mdresyncsize - mdresyncpos ))
            eta_seconds=$(( remaining_blocks / rate ))
        fi
        local eta_formatted=$(format_time_duration $eta_seconds)

        echo ""
        echo -e "Operation     : ${BLUE}$mdresyncaction${NC}"
        echo -e "Progress      : $progress% ($mdresyncpos/$mdresyncsize blocks)"
        echo -e "Speed         : $rate_mb MB/s"
        echo -e "Elapsed Time  : $elapsed_formatted"
        echo -e "ETA           : $eta_formatted"
    fi

    # List all disks in the array
    echo ""
    echo "=== Disk Status ==="
    echo ""
    echo -e "Slot  Status               Device            Size(GB)  Drive ID"
    echo -e "----  -------------------  ----------------  --------  -------------------------------------"

    # Special handling for parity disks
    for idx in 0 29; do
        local diskname=$(get_nmdstat_value "diskName.$idx")
        local diskid=$(get_nmdstat_value "diskId.$idx")
        local rdevstatus=$(get_nmdstat_value "rdevStatus.$idx")

        # Always display P, display Q if it has an ID OR it's a newly assigned disk (DISK_*_NEW)
        if [ "$idx" -eq 0 ] || [ -n "$diskid" ] || [[ "$rdevstatus" == DISK_*_NEW ]]; then
            local disksize=$(get_nmdstat_value "diskSize.$idx")
            local rdevname=$(get_nmdstat_value "rdevName.$idx")

            # For DISK_NEW, get size from rdevSize instead of diskSize
            if [[ ("$rdevstatus" = "DISK_NEW" || "$rdevstatus" = "DISK_DSBL_NEW") ]] && [ -z "$disksize" -o "$disksize" = "0" ]; then
                local rdevsize=$(get_nmdstat_value "rdevSize.$idx")
                if [ -n "$rdevsize" ] && [ "$rdevsize" -gt 0 ]; then
                    disksize="$rdevsize"
                fi

                # If diskId is empty but rdevId exists, use that
                if [ -z "$diskid" ]; then
                    diskid=$(get_nmdstat_value "rdevId.$idx")
                fi
            fi

            # Convert size to GB
            local sizegb=0
            if [ -n "$disksize" ] && [ "$disksize" -gt 0 ]; then
                sizegb=$(( (disksize + 1048575) / 1048576 ))
            fi

            local slottype=""
            if [ "$idx" -eq 0 ]; then
                slottype="P"
            elif [ "$idx" -eq 29 ]; then
                slottype="Q"
            fi

            if [ -n "$rdevstatus" ]; then
                local status_formatted=$(format_disk_status "$rdevstatus")

                # Map status to visible text length for alignment
                local visible_length=0
                case "$rdevstatus" in
                    "DISK_OK")
                        visible_length=2 # "OK"
                        ;;
                    "DISK_INVALID")
                        visible_length=7 # "INVALID"
                        ;;
                    "DISK_NP_MISSING")
                        visible_length=7 # "MISSING"
                        ;;
                    "DISK_WRONG")
                        visible_length=5 # "WRONG"
                        ;;
                    "DISK_DSBL"|"DISK_NP_DSBL"|"DISK_DSBL_NEW")
                        visible_length=8 # "DISABLED"
                        ;;
                    "DISK_NEW")
                        visible_length=3 # "NEW"
                        ;;
                    *)
                        visible_length=${#rdevstatus} # Use raw length as fallback
                        ;;
                esac

                # Fix alignment with proper field widths - need special handling for color codes
                printf "%-4s  " "$slottype"
                printf "%s" "$status_formatted"
                printf "%$((21 - visible_length))s" " " # Use visible length for padding
                printf "%-16s  %-8s  %s\n" "${rdevname:-none}" "$sizegb" "$diskid"
            fi
        fi
    done

    # Now list data disks
    for idx in $(seq 1 28); do
        local diskname=$(get_nmdstat_value "diskName.$idx")
        local rdevstatus=$(get_nmdstat_value "rdevStatus.$idx")

        # Display disk if it has a name OR it's a newly assigned disk (DISK_NEW)
        if [ -n "$diskname" ] || [ "$rdevstatus" = "DISK_NEW" ]; then
            local disksize=$(get_nmdstat_value "diskSize.$idx")
            local diskid=$(get_nmdstat_value "diskId.$idx")
            local rdevname=$(get_nmdstat_value "rdevName.$idx")
            local rdevnumerrors=$(get_nmdstat_value "rdevNumErrors.$idx")

            # For DISK_NEW, get size from rdevSize instead of diskSize
            if [ "$rdevstatus" = "DISK_NEW" ] && [ -z "$disksize" -o "$disksize" = "0" ]; then
                local rdevsize=$(get_nmdstat_value "rdevSize.$idx")
                if [ -n "$rdevsize" ] && [ "$rdevsize" -gt 0 ]; then
                    disksize="$rdevsize"
                fi

                # If diskId is empty but rdevId exists, use that
                if [ -z "$diskid" ]; then
                    diskid=$(get_nmdstat_value "rdevId.$idx")
                fi
            fi

            # Convert size to GB
            local sizegb=0
            if [ -n "$disksize" ] && [ "$disksize" -gt 0 ]; then
                sizegb=$(( (disksize + 1048575) / 1048576 ))
            fi

            local status_formatted=$(format_disk_status "$rdevstatus")

            # Map status to visible text length for alignment
            local visible_length=0
            case "$rdevstatus" in
                "DISK_OK")
                    visible_length=2 # "OK"
                    ;;
                "DISK_INVALID")
                    visible_length=7 # "INVALID"
                    ;;
                "DISK_NP_MISSING")
                    visible_length=7 # "MISSING"
                    ;;
                "DISK_WRONG")
                    visible_length=5 # "WRONG"
                    ;;
                "DISK_DSBL"|"DISK_NP_DSBL"|"DISK_DSBL_NEW")
                    visible_length=8 # "DISABLED"
                    ;;
                "DISK_NEW")
                    visible_length=3 # "NEW"
                    ;;
                *)
                    visible_length=${#rdevstatus} # Use raw length as fallback
                    ;;
            esac

            # Add indicator for disk errors
            if [ -n "$rdevnumerrors" ] && [ "$rdevnumerrors" -gt 0 ]; then
                status_formatted="$status_formatted ($rdevnumerrors errs)"
                # Account for the extra text in the visible length
                visible_length=$((visible_length + ${#rdevnumerrors} + 7))
            fi

            # Fix alignment with proper field widths - split into parts to handle color codes
            printf "%-4s  " "$idx"
            printf "%s" "$status_formatted"
            printf "%$((21 - visible_length))s" " " # Use visible length for padding
            printf "%-16s  %-8s  %s\n" "${rdevname:-none}" "$sizegb" "$diskid"
        fi
    done

    return 0
}

# Get disk size in 1K blocks
get_disk_size_kb() {
    local device="$1"
    if [ ! -b "$device" ]; then
        return 1
    fi

    # Use blockdev to get exact size in 512-byte sectors
    if command -v blockdev >/dev/null 2>&1; then
        local sectors=$(blockdev --getsz "$device" 2>/dev/null)
        if [ -n "$sectors" ]; then
            # Round down to nearest multiple of 8 sectors (driver reads/writes 8 sectors at a time)
            local adjusted_sectors=$(( (sectors / 8) * 8 ))
            # Convert to 1K blocks (2 sectors = 1KB)
            local kb_size=$(( adjusted_sectors / 2 ))
            echo "$kb_size"
            return 0
        fi
    fi

    # Fallback to fdisk if blockdev not available
    local sectors=$(fdisk -l "$device" 2>/dev/null | grep "^Disk $device" | awk '{print $7}')
    if [ -n "$sectors" ]; then
        # Round down to nearest multiple of 8 sectors (driver reads/writes 8 sectors at a time)
        local adjusted_sectors=$(( (sectors / 8) * 8 ))
        # Convert to 1K blocks (2 sectors = 1KB)
        local kb_size=$(( adjusted_sectors / 2 ))
        echo "$kb_size"
    else
        return 1
    fi
}

# Get disk ID from /dev/disk/by-id
get_disk_id() {
    local device="$1"

    # Get device name without /dev/
    local devname=$(basename "$device")

    # Use a safer approach to find the matching disk ID
    local disk_id=""
    if [ -d "/dev/disk/by-id" ]; then
        for id_path in /dev/disk/by-id/*; do
            if [ -L "$id_path" ] && [[ "$id_path" != *-part* ]]; then
                local link_target=$(readlink -f "$id_path")
                if [ "$(basename "$link_target")" = "$devname" ]; then
                    disk_id=$(basename "$id_path")
                    break
                fi
            fi
        done
    fi

    echo "$disk_id"
}

# Find disk device name matching the ID in nmdstat
find_matching_disk() {
    local disk_id="$1"

    # Check if disk_id is empty
    if [ -z "$disk_id" ]; then
        return 1
    fi

    # Look through /dev/disk/by-id to find matching disk
    if [ -d "/dev/disk/by-id" ]; then
        for id_path in /dev/disk/by-id/*; do
            # Skip if not a symlink or if it's a partition
            if [ ! -L "$id_path" ] || [[ "$id_path" == *-part* ]]; then
                continue
            fi

            local id_name=$(basename "$id_path")
            # If the disk ID contains the target ID, consider it a match
            if [[ "$id_name" == *"$disk_id"* ]]; then
                # Get the actual device the symlink points to
                local real_dev=$(readlink -f "$id_path")
                echo "$real_dev"
                return 0
            fi
        done
    fi

    return 1
}

# Import disks to array without starting it
import_disks() {
    check_root

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    echo "Scanning array configuration..."

    # Parse superblock to get disk IDs and slot assignments
    local num_disks=0
    local disks_to_import=()

    # Process all defined disk slots
    for slot in $(get_defined_slots); do
        local disk_id=$(get_nmdstat_value "diskId.$slot")

        # Check if this slot already has a device imported
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            echo -e "${YELLOW}Skipping slot $slot: Already has device $rdevname imported${NC}"
            continue
        fi

        # Check if this slot has been intentionally disabled (DISK_NP_MISSING status)
        local rdevstatus=$(get_nmdstat_value "rdevStatus.$slot")
        if [ "$rdevstatus" = "DISK_NP_MISSING" ]; then
            echo -e "${YELLOW}Skipping slot $slot: Disk has been unassigned (status: $rdevstatus)${NC}"
            continue
        fi

        # Find matching physical disk
        local found_device=""
        if [ -d "/dev/disk/by-id" ]; then
            found_device=$(find_matching_disk "$disk_id")
        fi

        # Check if device exists and has a first partition
        local partition=""
        if [ -n "$found_device" ]; then
            # Check for partitions
            if [ -b "${found_device}1" ]; then
                partition="${found_device}1"
            elif [ -b "${found_device}p1" ]; then
                partition="${found_device}p1"
            fi

            if [ -n "$partition" ]; then
                # Get the partition size
                local disk_size=$(get_disk_size_kb "$partition")

                if [ -n "$disk_size" ]; then
                    # Get the configured size from nmdstat
                    local configured_size=$(get_nmdstat_value "diskSize.$slot")
                    local size_to_use="$disk_size"
                    local size_mismatch=0

                    # If we have a configured size and it differs from actual size
                    if [ -n "$configured_size" ] && [ "$configured_size" -gt 0 ] && [ "$configured_size" -ne "$disk_size" ]; then
                        size_mismatch=1
                        echo -e "${YELLOW}Warning: Size mismatch for disk in slot $slot${NC}"
                        echo -e "  Partition size: $disk_size KB"
                        echo -e "  Expected size : $configured_size KB"

                        # Ask for confirmation
                        read -p "Use the configured size instead of detected size? (y/N): " confirm
                        if [[ "$confirm" =~ ^[Yy]$ ]]; then
                            size_to_use="$configured_size"
                            echo -e "Using configured size: ${BLUE}$configured_size KB${NC}"
                        else
                            echo -e "Using detected partition size: ${BLUE}$disk_size KB${NC}"
                        fi
                    fi

                    echo -e "Found disk for slot $slot: ${BLUE}$(basename "$partition")${NC} (ID: ${disk_id:0:25}...)"

                    # Store partition name without /dev/
                    partition=$(basename "$partition")

                    # Add to import list: slot, partition, offset, size, erased, id
                    disks_to_import+=("$slot|$partition|0|$size_to_use|0|$disk_id")
                    num_disks=$((num_disks + 1))
                else
                    echo -e "${YELLOW}Warning: Could not determine size for $partition${NC}"
                fi
            else
                echo -e "${YELLOW}Warning: No partition found for disk $found_device${NC}"
            fi
        else
            echo -e "${YELLOW}Warning: Could not find physical disk for ID: ${disk_id:0:25}...${NC}"
        fi
    done

    # Check if we found any disks to import
    if [ "$num_disks" -eq 0 ]; then
        # Check if disks were already imported (check for any rdevName values)
        local already_imported=0
        for slot in $(grep -E "^diskId\.[0-9]+" /proc/nmdstat | cut -d'.' -f2 | cut -d'=' -f1); do
            local rdevname=$(get_nmdstat_value "rdevName.$slot")
            if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
                already_imported=$((already_imported + 1))
            fi
        done

        if [ "$already_imported" -gt 0 ]; then
            echo -e "${GREEN}All disks already imported ($already_imported disk(s) found)${NC}"
        else
            echo -e "${RED}Error: No disks found to import${NC}"
            return 1
        fi
    else
        echo ""
        echo "Importing $num_disks disks..."

        # Import each disk
        for disk_data in "${disks_to_import[@]}"; do
            IFS='|' read -r slot partition offset size erased id <<< "$disk_data"

            echo -e "Importing disk to slot $slot: ${BLUE}$partition${NC}"
            if ! run_nmd_command "import $slot $partition $offset $size $erased $id"; then
                echo -e "${RED}Error: Failed to import disk to slot $slot${NC}"
            fi
        done

        echo -e "${GREEN}Successfully imported $num_disks disk(s)${NC}"
    fi

    echo ""
    # Show array status after importing
    show_status

    return 0
}

# Start the array by importing disks and starting the array
start_array() {
    check_root

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check current array state
    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" = "STARTED" ]; then
        echo -e "${YELLOW}Array is already started${NC}"
        return 0
    fi

    # Import disks first
    import_disks

    echo ""
    # Check array state after imports
    mdstate=$(get_nmdstat_value "mdState")

    # Check if all defined disks have been imported
    local defined_slots=$(get_defined_slots_count)
    local imported_disks=0
    local missing_slots=()

    # Count imported disks and track which ones are missing
    for slot in $(get_defined_slots); do
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        local rdevstatus=$(get_nmdstat_value "rdevStatus.$slot")

        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            imported_disks=$((imported_disks + 1))
        elif [ "$rdevstatus" != "DISK_NP_MISSING" ]; then
            # Only consider it missing if it's not intentionally unassigned
            missing_slots+=("$slot")
        fi
    done

    # If we have missing disks that aren't explicitly unassigned, don't allow starting
    if [ ${#missing_slots[@]} -gt 0 ]; then
        echo -e "${RED}Error: Cannot start array with missing disks${NC}"
        echo -e "${YELLOW}The following disk slots are defined but not imported:${NC} ${missing_slots[*]}"
        echo -e "${YELLOW}You must either:${NC}"
        echo -e "  1. Import the missing disk(s) with ${GREEN}nmdctl import${NC}"
        echo -e "  2. Unassign the missing disk(s) with ${GREEN}nmdctl unassign SLOT${NC}"
        return 1
    fi

    # Check array state and proceed based on it
    if [ "$mdstate" = "STOPPED" ]; then
        # Normal state, proceed without confirmation
        echo "Array is in normal STOPPED state"
        if ! run_nmd_command "start"; then
            echo -e "${RED}Error: Failed to start array${NC}"
            return 1
        fi
    else
        # Abnormal state, require confirmation
        echo -e "${YELLOW}Array is in abnormal state: $mdstate${NC}"

        case "$mdstate" in
            "NEW_ARRAY")
                echo -e "${YELLOW}This is a NEW_ARRAY and will require parity construction.${NC}"
                ;;
            "RECON_DISK")
                echo -e "${YELLOW}One or more disks need reconstruction.${NC}"
                ;;
            "DISABLE_DISK")
                echo -e "${YELLOW}Array will run in degraded mode with missing disk(s).${NC}"
                ;;
            "SWAP_DSBL")
                echo -e "${YELLOW}Parity disk(s) need to be rearranged.${NC}"
                ;;
            "ERROR:"*)
                echo -e "${RED}Array is in ERROR state. Starting may fail or cause data loss.${NC}"
                ;;
        esac

        # Ask for confirmation
        read -p "Do you want to continue starting the array in this state? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "Proceeding with array start in $mdstate state"
            if ! run_nmd_command "start $mdstate"; then
                echo -e "${RED}Error: Failed to start array${NC}"
                return 1
            fi
        else
            echo "Array start cancelled by user"
            return 1
        fi
    fi

    echo -e "${GREEN}Array started successfully${NC}"
    echo ""

    # Show array status
    show_status

    return 0
}

# Stop the array
stop_array() {
    check_root

    if ! check_nmdstat_exists; then
        return 1
    fi

    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${YELLOW}Array is not running (current state: $mdstate)${NC}"
        return 0
    fi

    echo "Stopping array..."
    if ! run_nmd_command "stop"; then
        echo -e "${RED}Error: Failed to stop array${NC}"
        return 1
    fi

    echo -e "${GREEN}Array stopped successfully${NC}"
    return 0
}

# Start parity check
start_check() {
    local option="${1:-CORRECT}"
    check_root

    if ! check_nmdstat_exists; then
        return 1
    fi

    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${RED}Error: Array must be started to run parity check${NC}"
        return 1
    fi

    echo "Starting parity check with option $option..."
    if ! run_nmd_command "check $option"; then
        echo -e "${RED}Error: Failed to start parity check${NC}"
        return 1
    fi

    echo -e "${GREEN}Parity check started${NC}"
    return 0
}

# Stop parity check
stop_check() {
    local option="${1:-CANCEL}"
    check_root

    if ! check_nmdstat_exists; then
        return 1
    fi

    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${RED}Error: Array must be started to stop parity check${NC}"
        return 1
    fi

    echo "Stopping parity check with option $option..."
    if ! run_nmd_command "nocheck $option"; then
        echo -e "${RED}Error: Failed to stop parity check${NC}"
        return 1
    fi

    echo -e "${GREEN}Parity check stopped${NC}"
    return 0
}

# List available block devices with single partitions
list_available_devices() {
    local devices=()

    # Find all disk devices
    for dev in /dev/sd*; do
        # Skip if not a block device or if it's a partition
        if [ ! -b "$dev" ] || [[ "$dev" == *[0-9] ]]; then
            continue
        fi

        # Check if the device has exactly one partition
        local partition_count=$(ls -l ${dev}* 2>/dev/null | grep -E "${dev}[0-9]+" | wc -l)
        if [ "$partition_count" -eq 1 ]; then
            # Get the partition device
            local partition=""
            if [ -b "${dev}1" ]; then
                partition="${dev}1"
            elif [ -b "${dev}p1" ]; then
                partition="${dev}p1"
            else
                continue  # Skip if we can't find the partition
            fi

            # Get device details using a more reliable approach
            # Get disk ID without using xargs and pipeline
            local disk_id=""
            if [ -d "/dev/disk/by-id" ]; then
                local dev_name=$(basename "$dev")
                # Use a safer approach to find the matching disk ID
                for id_path in /dev/disk/by-id/*; do
                    if [ -L "$id_path" ] && [[ "$id_path" != *-part* ]]; then
                        local link_target=$(readlink -f "$id_path")
                        if [ "$(basename "$link_target")" = "$dev_name" ]; then
                            disk_id=$(basename "$id_path")
                            break
                        fi
                    fi
                done
            fi

            # Get disk size information
            local size_kb=$(get_disk_size_kb "$partition")
            local size_gb=0
            if [ -n "$size_kb" ] && [ "$size_kb" -gt 0 ]; then
                size_gb=$(( (size_kb + 1048575) / 1048576 ))
            fi

            # Add to available devices
            devices+=("$dev|$partition|$size_kb|$size_gb|$disk_id")
        fi
    done

    echo "${devices[@]}"
}

# Create a new array with interactive disk assignment
create_array() {
    check_root

    # Get current superblock path
    local superblock="${SUPERBLOCK_PATH:-$DEFAULT_SUPERBLOCK}"
    local is_new_superblock=0

    # Check if this will be a new superblock
    if [ ! -f "$superblock" ]; then
        is_new_superblock=1
        echo -e "${BLUE}Creating a new array with a new superblock at: ${GREEN}$superblock${NC}"
        echo -e "${YELLOW}Note: The superblock file will be created when the array is started${NC}"
    fi

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Verify no disks are defined in the array
    local disk_count=$(get_defined_slots_count)
    if [ "$disk_count" -gt 0 ] && [ "$is_new_superblock" -eq 0 ]; then
        echo -e "${RED}Error: The array already has $disk_count disk(s) defined${NC}"
        echo -e "${YELLOW}To create a new array, unload and reload the module with a new or empty superblock${NC}"
        echo -e "Use: ${GREEN}nmdctl --super /path/to/new/superblock.dat reload${NC}"
        return 1
    fi

    echo -e "=== ${BLUE}Creating New NonRAID Array${NC} ==="
    echo ""
    echo -e "${YELLOW}This will create a new array and assign disks to slots.${NC}"
    echo -e "${YELLOW}Only devices with a single partition will be shown.${NC}"
    echo ""

    # Get available devices
    echo "Scanning for available disks..."
    local available_devices=($(list_available_devices))

    if [ ${#available_devices[@]} -eq 0 ]; then
        echo -e "${RED}Error: No suitable disk devices found${NC}"
        echo -e "${YELLOW}Make sure disks are connected and have a single partition${NC}"
        return 1
    fi

    echo -e "Found ${GREEN}${#available_devices[@]}${NC} suitable devices with partitions"
    echo ""

    # Ask for array label
    local array_label=""
    read -p "Enter a label for the array (optional): " array_label
    if [ -n "$array_label" ]; then
        # Set array label if provided
        echo "Setting array label: $array_label"
        run_nmd_command "label $array_label"
    fi
    echo ""

    local assigned_slots=()
    local assigned_count=0

    # Display available slots explanation
    echo -e "${BLUE}Slot Assignment Guidelines:${NC}"
    echo -e " - Slot P (0): Parity disk (largest disk recommended)"
    echo -e " - Slot Q (29): Optional second parity for dual parity (not required)"
    echo -e " - Slots 1-28: Data disks"
    echo ""

    # Process each device
    for device_info in "${available_devices[@]}"; do
        IFS='|' read -r dev partition size_kb size_gb disk_id <<< "$device_info"

        echo -e "=== Disk: ${BLUE}$(basename "$dev")${NC} ==="
        echo -e "Partition: $(basename "$partition")"
        echo -e "Size: $size_gb GB"
        if [ -n "$disk_id" ]; then
            echo -e "ID: $disk_id"
        else
            echo -e "ID: Unknown"
        fi
        echo ""

        # Show which slots are already assigned
        if [ ${#assigned_slots[@]} -gt 0 ]; then
            echo -e "Assigned slots: ${GREEN}${assigned_slots[*]}${NC}"
            echo ""
        fi

        # Ask for slot assignment
        while true; do
            echo -e "Enter slot assignment for this disk:"
            echo -e " P or 0: Parity disk"
            echo -e " Q or 29: Second parity disk (optional)"
            echo -e " 1-28: Data disk"
            echo -e " s: Skip this disk"
            echo -e " f: Finish array creation"
            read -p "Choice: " choice

            local slot=""
            case "$choice" in
                [Pp])
                    slot="0"
                    ;;
                [Qq])
                    slot="29"
                    ;;
                [0-9]|[0-2][0-9])
                    # Check if slot is valid (0-29)
                    if [ "$choice" -ge 0 ] && [ "$choice" -le 29 ]; then
                        slot="$choice"
                    else
                        echo -e "${RED}Invalid slot number. Please use 0-29.${NC}"
                        continue
                    fi
                    ;;
                [Ss])
                    echo -e "${YELLOW}Skipping disk ${BLUE}$(basename "$dev")${NC}"
                    break
                    ;;
                [Ff])
                    echo "Finishing array creation..."
                    break 2  # Break out of both loops
                    ;;
                *)
                    echo -e "${RED}Invalid choice. Please try again.${NC}"
                    continue
                    ;;
            esac

            if [ -n "$slot" ]; then
                # Check if slot is already assigned
                if [[ " ${assigned_slots[@]} " =~ " $slot " ]]; then
                    echo -e "${RED}Error: Slot $slot is already assigned. Please choose another slot.${NC}"
                    continue
                fi

                # Import disk to slot
                echo -e "Importing disk to slot $slot: ${BLUE}$(basename "$partition")${NC}"

                # Get disk ID (use device path if no ID)
                local id_to_use="${disk_id:-$(basename "$dev")}"

                # Import disk: slot, partition, offset, size, erased, id
                if ! run_nmd_command "import $slot $(basename "$partition") 0 $size_kb 0 $id_to_use"; then
                    echo -e "${RED}Error: Failed to import disk to slot $slot${NC}"
                else
                    echo -e "${GREEN}Successfully imported disk to slot $slot${NC}"
                    assigned_slots+=("$slot")
                    assigned_count=$((assigned_count + 1))
                fi
                break
            fi
        done

        echo ""
    done

    # Check if any disks were assigned
    if [ "$assigned_count" -eq 0 ]; then
        echo -e "${YELLOW}No disks were assigned to the array.${NC}"
        return 0
    fi

    echo -e "${GREEN}Successfully assigned $assigned_count disk(s) to the array${NC}"

    # Show array status
    echo ""
    show_status

    # Ask if user wants to start the array now
    echo ""
    read -p "Do you want to start the array now? (y/N): " start_now
    if [[ "$start_now" =~ ^[Yy]$ ]]; then
        start_array
    else
        echo -e "${YELLOW}Array creation complete. You can start it with: ${GREEN}nmdctl start${NC}"
    fi
    # XXX: FIXME: driver internal state gets inconsistent after creating a new array
    # XXX: FIXME: need to reload the module to reset internal state
    echo ""
    echo -e "${YELLOW}Note: You may need to reload the module to reset the internal state"
    echo -e "if after parity reconstruction the array state is still DEGRADED.${NC}"
    echo -e "${YELLOW}Use: ${GREEN}nmdctl reload${NC}"
    return 0
}

# Add a new disk to the array
add_disk() {
    check_root

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check current array state
    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" = "STARTED" ]; then
        echo -e "${RED}Error: Array is currently running${NC}"
        echo -e "${YELLOW}Stop the array first with: ${GREEN}nmdctl stop${NC}"
        return 1
    fi

    if [ "$mdstate" = "NEW_ARRAY" ]; then
        echo -e "${RED}Error: Cannot add disk to a new array${NC}"
        echo -e "${YELLOW}Start the array first to build parity: ${GREEN}nmdctl start${NC}"
        return 1
    fi

    # Count the number of disks that have been imported
    local imported_disks=0
    local total_slots=$(get_defined_slots_count)
    for slot in $(get_defined_slots); do
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            imported_disks=$((imported_disks + 1))
        fi
    done

    if [ "$imported_disks" -lt "$total_slots" ]; then
        echo -e "${YELLOW}Warning: Not all disks have been imported ($imported_disks/$total_slots)${NC}"
        echo -e "${YELLOW}It's recommended to import all existing disks before adding a new one${NC}"
        read -p "Continue anyway? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled."
            return 1
        fi
    fi

    # Check if we have any new disks already
    local mdnumnew=$(get_nmdstat_value "mdNumNew")
    if [ -n "$mdnumnew" ] && [ "$mdnumnew" -gt 0 ]; then
        echo -e "${RED}Error: Array already has a new disk added${NC}"
        echo -e "${YELLOW}The driver only supports adding one disk at a time.${NC}"
        echo -e "${YELLOW}Start the array to process the current new disk first: ${GREEN}nmdctl start${NC}"
        return 1
    fi

    echo -e "=== ${BLUE}Add New Disk to Array${NC} ==="
    echo ""
    echo -e "${YELLOW}This will add a single new disk to the array.${NC}"
    echo -e "${YELLOW}After adding the disk, you must start the array to process it.${NC}"
    echo -e "${YELLOW}Only devices with a single partition will be shown.${NC}"
    echo ""

    # Get available devices
    echo "Scanning for available disks..."
    local all_available_devices=($(list_available_devices))

    if [ ${#all_available_devices[@]} -eq 0 ]; then
        echo -e "${RED}Error: No suitable disk devices found${NC}"
        echo -e "${YELLOW}Make sure disks are connected and have a single partition${NC}"
        return 1
    fi

    # Get list of all disk IDs already in the array
    local array_disk_ids=()
    for slot in $(seq 0 29); do
        local disk_id=$(get_nmdstat_value "diskId.$slot")
        if [ -n "$disk_id" ] && [ "$disk_id" != "none" ]; then
            array_disk_ids+=("$disk_id")
        fi

        # Also check rdevId for newly added disks
        local rdev_id=$(get_nmdstat_value "rdevId.$slot")
        if [ -n "$rdev_id" ] && [ "$rdev_id" != "none" ]; then
            array_disk_ids+=("$rdev_id")
        fi
    done

    # Filter out disks that are already part of the array
    local available_devices=()
    local filtered_count=0

    for device_info in "${all_available_devices[@]}"; do
        IFS='|' read -r dev partition size_kb size_gb disk_id <<< "$device_info"
        local already_in_array=false

        # Skip if disk has no ID (unusual but possible)
        if [ -z "$disk_id" ]; then
            continue
        fi

        # Check if this disk ID is already in the array
        for array_id in "${array_disk_ids[@]}"; do
            # If the disk ID contains the array ID or vice versa, consider it a match
            if [[ "$disk_id" == *"$array_id"* ]] || [[ "$array_id" == *"$disk_id"* ]]; then
                already_in_array=true
                filtered_count=$((filtered_count + 1))
                break
            fi
        done

        # If not already in array, add to available devices
        if ! $already_in_array; then
            available_devices+=("$device_info")
        fi
    done

    if [ ${#available_devices[@]} -eq 0 ]; then
        echo -e "${RED}Error: No suitable disk devices found${NC}"
        if [ $filtered_count -gt 0 ]; then
            echo -e "${YELLOW}Found $filtered_count disk(s), but all are already part of the array${NC}"
        else
            echo -e "${YELLOW}Make sure disks are connected and have a single partition${NC}"
        fi
        return 1
    fi

    echo -e "Found ${GREEN}${#available_devices[@]}${NC} suitable devices with partitions"
    if [ $filtered_count -gt 0 ]; then
        echo -e "(Filtered out $filtered_count disk(s) that are already part of the array)"
    fi
    echo ""

    # Find available slots
    local used_slots=()
    local available_slots=()

    used_slots=($(get_defined_slots))

    # Then, determine which slots are available
    for slot in $(seq 1 28); do
        if ! [[ " ${used_slots[@]} " =~ " $slot " ]]; then
            available_slots+=("$slot")
        fi
    done

    # Check if parity disks (slots 0 and 29) are used
    local has_parity=false
    local has_second_parity=false

    if [[ " ${used_slots[@]} " =~ " 0 " ]]; then
        has_parity=true
    fi

    if [[ " ${used_slots[@]} " =~ " 29 " ]]; then
        has_second_parity=true
    fi

    # If no parity disk, suggest adding that first
    if ! $has_parity; then
        available_slots+=("0")
        echo -e "${YELLOW}No parity disk found. Consider adding a parity disk (slot 0).${NC}"
    fi

    # If no second parity disk, suggest adding that as an option
    if ! $has_second_parity; then
        available_slots+=("29")
        echo -e "${YELLOW}No second parity disk found. You may add one (slot 29) for dual parity.${NC}"
    fi

    # Check if we have any available slots
    if [ ${#available_slots[@]} -eq 0 ]; then
        echo -e "${RED}Error: No available slots in the array${NC}"
        echo -e "${YELLOW}All possible slots are already assigned.${NC}"
        return 1
    fi

    echo -e "Available slots: ${GREEN}${available_slots[*]}${NC}"
    echo ""

    # Display information about slot types
    echo -e "${BLUE}Slot Types:${NC}"
    echo -e " - Slot 0: Primary parity disk"
    echo -e " - Slot 29: Secondary parity disk (for dual parity)"
    echo -e " - Slots 1-28: Data disks"
    echo ""

    # Select a single device
    local selected_device=""
    local selected_dev=""
    local selected_partition=""
    local selected_size_kb=0
    local selected_size_gb=0
    local selected_disk_id=""

    echo -e "Available devices:"
    echo ""
    echo -e "  #  Device      Size(GB)  ID"
    echo -e "  -  ----------  --------  ---------------------------------"

    local device_index=1
    for device_info in "${available_devices[@]}"; do
        IFS='|' read -r dev partition size_kb size_gb disk_id <<< "$device_info"

        # Show shortened disk ID for clarity
        local short_id="${disk_id}"
        if [ ${#short_id} -gt 25 ]; then
            short_id="${short_id:0:22}..."
        fi

        printf "  %-2d  %-10s  %-8s  %s\n" \
            "$device_index" \
            "$(basename "$dev")" \
            "$size_gb" \
            "$short_id"

        device_index=$((device_index + 1))
    done

    echo ""

    # Select device
    while true; do
        read -p "Enter device number to add (1-${#available_devices[@]}) or 'q' to quit: " choice

        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            echo "Operation cancelled."
            return 0
        fi

        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#available_devices[@]} ]; then
            echo -e "${RED}Invalid choice. Please enter a number between 1 and ${#available_devices[@]}.${NC}"
            continue
        fi

        selected_device="${available_devices[$((choice-1))]}"
        IFS='|' read -r selected_dev selected_partition selected_size_kb selected_size_gb selected_disk_id <<< "$selected_device"

        # Display selected disk details in the same format as create_array
        echo ""
        echo -e "=== Selected disk: ${BLUE}$(basename "$selected_dev")${NC} ==="
        echo -e "Partition: $(basename "$selected_partition")"
        echo -e "Size: $selected_size_gb GB"
        if [ -n "$selected_disk_id" ]; then
            echo -e "ID: $selected_disk_id"
        else
            echo -e "ID: Unknown"
        fi
        echo ""

        break
    done

    # Select slot
    local selected_slot=""
    while true; do
        echo -e "Enter slot assignment for this disk:"
        echo -e " P or 0: Parity disk"
        echo -e " Q or 29: Second parity disk (optional)"
        echo -e " 1-28: Data disk"
        echo -e " a: Abort adding disk"
        read -p "Choice: " choice

        if [ "$choice" = "a" ] || [ "$choice" = "A" ]; then
            echo "Operation cancelled."
            return 0
        fi

        # Convert P/Q to slot numbers
        case "$choice" in
            [Pp])
                choice="0"
                ;;
            [Qq])
                choice="29"
                ;;
        esac

        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}Invalid choice. Please enter a valid slot number or P/Q.${NC}"
            continue
        fi

        # Check if selected slot is available
        if ! [[ " ${available_slots[@]} " =~ " $choice " ]]; then
            echo -e "${RED}Invalid slot. Please choose from available slots: ${available_slots[*]}.${NC}"
            continue
        fi

        selected_slot="$choice"
        break
    done

    # Format the slot name for display
    local slot_display="$selected_slot"
    if [ "$selected_slot" = "0" ]; then
        slot_display="P (0)"
    elif [ "$selected_slot" = "29" ]; then
        slot_display="Q (29)"
    fi

    echo -e "Selected slot: ${BLUE}$slot_display${NC}"
    echo ""

    # Confirm selection
    echo -e "You are about to add: ${BLUE}$(basename "$selected_dev")${NC} to slot ${BLUE}$slot_display${NC}"
    read -p "Proceed with adding this disk? (y/N): " confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Operation cancelled."
        return 0
    fi

    echo ""
    echo -e "Adding disk to array..."

    # Get disk ID (use device path if no ID)
    local id_to_use="${selected_disk_id:-$(basename "$selected_dev")}"

    # Import disk: slot, partition, offset, size, erased, id
    if ! run_nmd_command "import $selected_slot $(basename "$selected_partition") 0 $selected_size_kb 0 $id_to_use"; then
        echo -e "${RED}Error: Failed to add disk to slot $selected_slot${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully added disk to slot $selected_slot${NC}"
    echo ""

    # Show array status
    show_status

    echo ""
    echo -e "${YELLOW}To complete adding the disk, you need to:${NC}"
    echo -e "1. ${YELLOW}Start the array:${NC} ${GREEN}nmdctl start${NC}"
    if [ "$selected_slot" -eq 0 ] || [ "$selected_slot" -eq 29 ]; then
        echo -e "2. ${YELLOW}Reconstruct new parity: ${GREEN}nmdctl check${NC}"
    else
        echo -e "2. ${YELLOW}Clear the new data disk: ${GREEN}nmdctl check${NC}"
    fi
    echo -e "${YELLOW}Note: You cannot add another disk until this process completes.${NC}"

    return 0
}

# Unassign a disk from a specified slot
unassign_disk() {
    local slot="$1"

    # Check if we have a slot parameter
    if [ -z "$slot" ]; then
        echo -e "${RED}Error: Missing slot parameter${NC}"
        echo -e "Usage: ${YELLOW}nmdctl unassign SLOT${NC}"
        echo -e "Example: ${YELLOW}nmdctl unassign 1${NC} (to unassign disk from slot 1)"
        echo -e "Special slots: ${YELLOW}P${NC} or ${YELLOW}0${NC} (parity disk), ${YELLOW}Q${NC} or ${YELLOW}29${NC} (second parity)"
        return 1
    fi

    # Handle P/Q notation
    case "$slot" in
        [Pp])
            slot="0"
            ;;
        [Qq])
            slot="29"
            ;;
    esac

    # Validate slot is a number
    if ! [[ "$slot" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Slot must be a number${NC}"
        return 1
    fi

    # Check if valid slot range (0-29)
    if [ "$slot" -lt 0 ] || [ "$slot" -gt 29 ]; then
        echo -e "${RED}Error: Invalid slot number. Valid slots are 0-29${NC}"
        return 1
    fi

    check_root

    # Check if module is loaded
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check if array is stopped
    local mdstate=$(get_nmdstat_value "mdState")
    if [ "$mdstate" = "STARTED" ]; then
        echo -e "${RED}Error: Array must be stopped before unassigning disks${NC}"
        echo -e "Stop the array with: ${YELLOW}nmdctl stop${NC}"
        return 1
    fi

    # Get disk information for the slot
    local disk_id=$(get_nmdstat_value "diskId.$slot")
    local rdev_name=$(get_nmdstat_value "rdevName.$slot")
    local rdev_status=$(get_nmdstat_value "rdevStatus.$slot")
    local disk_size=$(get_nmdstat_value "diskSize.$slot")
    local rdev_size=$(get_nmdstat_value "rdevSize.$slot")
    local size_gb=0

    # Calculate size in GB if available
    if [ -n "$disk_size" ] && [ "$disk_size" -gt 0 ]; then
        size_gb=$(( (disk_size + 1048575) / 1048576 ))
    elif [ -n "$rdev_size" ] && [ "$rdev_size" -gt 0 ]; then
        size_gb=$(( (rdev_size + 1048575) / 1048576 ))
    fi

    # Check if the slot has a disk assigned
    if [ -z "$disk_id" ]; then
        echo -e "${RED}Error: No disk assigned to slot $slot${NC}"
        return 1
    fi

    # Format the slot name for display
    local slot_display="$slot"
    if [ "$slot" = "0" ]; then
        slot_display="P (0)"
    elif [ "$slot" = "29" ]; then
        slot_display="Q (29)"
    fi

    # Display slot information
    echo -e "=== Disk in Slot ${BLUE}$slot_display${NC} ==="
    echo -e "Disk ID      : $disk_id"
    if [ -n "$rdev_name" ] && [ "$rdev_name" != "none" ]; then
        echo -e "Device       : $rdev_name"
    else
        echo -e "Device       : ${YELLOW}Not imported${NC}"
    fi
    echo -e "Status       : $(format_disk_status "$rdev_status")"
    echo -e "Size         : $size_gb GB"
    echo ""

    # Warn about potential data loss
    echo -e "${RED}WARNING: Unassigning this disk will remove it from the array.${NC}"
    if [ "$slot" = "0" ] || [ "$slot" = "29" ]; then
        echo -e "${RED}This is a PARITY disk. Unassigning it will remove parity protection.${NC}"
    else
        echo -e "${RED}This is a DATA disk. Unassigning it will cause its contents to be emulated via parity (if available).${NC}"
    fi
    echo ""

    # Ask for confirmation
    read -p "Are you sure you want to unassign this disk? (y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Operation cancelled."
        return 1
    fi

    echo ""
    echo -e "Unassigning disk from slot $slot_display..."

    # Unassign the disk by importing an empty device
    if ! run_nmd_command "import $slot '' 0 0 0 ''"; then
        echo -e "${RED}Error: Failed to unassign disk from slot $slot${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully unassigned disk from slot $slot_display${NC}"
    echo ""

    # Show array status
    show_status

    return 0
}

# Reload nonraid module with superblock
reload_module() {
    check_root

    # Get current superblock path
    local superblock=""

    # If --super wasn't provided, try to get the current superblock path from nmdstat
    if [ -z "$SUPERBLOCK_PATH" ] && [ -f /proc/nmdstat ]; then
        local current_superblock=$(get_nmdstat_value "sbName")
        if [ -n "$current_superblock" ] && [ "$current_superblock" != "(null)" ]; then
            superblock="$current_superblock"
            echo -e "Using current superblock from running module: ${GREEN}$superblock${NC}"
        else
            superblock="$DEFAULT_SUPERBLOCK"
        fi
    else
        superblock="${SUPERBLOCK_PATH:-$DEFAULT_SUPERBLOCK}"
    fi

    # Check if superblock file exists, but allow non-existent files for creating new arrays
    if [ ! -f "$superblock" ]; then
        echo -e "${YELLOW}Warning: Superblock file not found: $superblock${NC}"
        echo -e "${YELLOW}This will create a new superblock when the array is started.${NC}"

        # Ask for confirmation if creating a new superblock
        read -p "Continue with a new superblock? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled."
            return 1
        fi
        echo -e "Proceeding with new superblock at: ${GREEN}$superblock${NC}"
    fi

    # Check if module is loaded
    if ! lsmod | grep -q nonraid; then
        echo -e "${YELLOW}NonRAID module not loaded. Loading with superblock: $superblock${NC}"
        modprobe nonraid super="$superblock"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to load nonraid module${NC}"
            return 1
        fi
        echo -e "${GREEN}Successfully loaded nonraid module${NC}"
        return 0
    fi

    echo -e "${YELLOW}Stopping array and reloading nonraid module...${NC}"

    # Stop array if it's running
    local mdstate=""
    if [ -f /proc/nmdstat ]; then
        mdstate=$(get_nmdstat_value "mdState")
        if [ "$mdstate" = "STARTED" ]; then
            echo "Stopping array first..."
            if ! run_nmd_command "stop"; then
                echo -e "${RED}Error: Failed to stop array. Cannot safely reload module.${NC}"
                return 1
            fi
            echo -e "Array stopped successfully."
        fi
    fi

    # Unload module
    echo "Unloading nonraid module..."
    modprobe -r nonraid
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to unload nonraid module. It may be in use.${NC}"
        return 1
    fi

    # Small delay to ensure module is fully unloaded
    sleep 1

    # Load module with specified superblock
    echo "Loading nonraid module with superblock: $superblock"
    modprobe nonraid super="$superblock"
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to reload nonraid module${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully reloaded nonraid module with superblock: $superblock${NC}"
    return 0
}

# Main entry point
main() {
    # Check for at least one argument
    if [ $# -eq 0 ]; then
        usage
    fi

    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "-s"|"--super")
                if [ -z "$2" ] || [[ "$2" == -* ]]; then
                    echo -e "${RED}Error: --super requires a path argument${NC}"
                    usage
                fi
                SUPERBLOCK_PATH="$2"
                shift 2
                ;;
            "-h"|"--help"|"help")
                usage
                ;;
            *)
                # Not a global option, should be a command
                break
                ;;
        esac
    done

    # No command provided after global options
    if [ $# -eq 0 ]; then
        usage
    fi

    # Parse command
    local command="$1"
    shift

    case "$command" in
        "status")
            show_status
            ;;
        "create")
            create_array
            ;;
        "start")
            start_array
            ;;
        "stop")
            stop_array
            ;;
        "import")
            import_disks
            ;;
        "add")
            add_disk
            ;;
        "unassign")
            unassign_disk "$1"
            ;;
        "reload")
            reload_module
            ;;
        "check")
            start_check "$1"
            ;;
        "nocheck")
            stop_check "$1"
            ;;
        *)
            echo -e "${RED}Error: Unknown command '$command'${NC}"
            usage
            ;;
    esac

    exit $?
}

# Run main function
main "$@"
