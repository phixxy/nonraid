#!/bin/bash
# shellcheck disable=SC2155,SC2207
#
# nmdctl - NonRAID array management utility
#


# Check for bash version 4 or higher (needed for associative arrays)
if ((BASH_VERSINFO[0] < 4)); then
    echo "Error: This script requires bash version 4 or higher"
    exit 1
fi

# Colors for pretty output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default superblock path
DEFAULT_SUPERBLOCK="/nonraid.dat"
SUPERBLOCK_PATH=""

# LUKS keyfile path
LUKS_KEYFILE="/etc/nonraid/luks-keyfile"

# verbose & unattended
VERBOSE=0
UNATTENDED=0

# Global associative array for nmdstat values
declare -A NMDSTAT_VALUES

# Display usage information
usage() {
    echo "nmdctl - NonRAID array management utility"
    echo ""
    echo "Usage: nmdctl [GLOBAL OPTIONS] COMMAND [COMMAND OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  status                      Show current array status"
    echo "  create                      Create a new array with interactive disk assignment"
    echo "  start                       Start the array"
    echo "  stop                        Stop the array"
    echo "  import                      Import all disks to the array without starting it"
    echo "  add                         Add a new disk to the array interactively"
    echo "  unassign SLOT               Unassign a disk from the specified slot"
    echo "  reload                      Reload nonraid module with specified superblock"
    echo "  check [OPTION]              Start parity check (CORRECT (default), NOCORRECT or RESUME)"
    echo "  nocheck [CANCEL|PAUSE]      Stop parity check (CANCEL or PAUSE)"
    echo "  mount [MOUNTPREFIX]         Mount all active data disks (default prefix: /mnt/disk)"
    echo "  unmount                     Unmount all active data disks"
    echo ""
    echo "Global Options:"
    echo "  -s, --super PATH            Superblock file path to use when loading the module (default: $DEFAULT_SUPERBLOCK)"
    echo "  -k, --keyfile PATH          Path to LUKS keyfile to use during mounting (default: $LUKS_KEYFILE)"
    echo "  -u, --unattended            Enable unattended mode, will import and start a healthy array without prompts"
    echo "  -v, --verbose               Enable verbose output"
    echo "  -h, --help                  Display this help message"
    echo ""
    exit 1
}

# Check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}Error: This command must be run as root${NC}"
        exit 1
    fi
}

# Run a command via nmdcmd
run_nmd_command() {
    check_root
    if ! echo "$1" > /proc/nmdcmd; then
        echo -e "${RED}Error: Failed to run command '$1'${NC}"
        return 1
    fi
    return 0
}

# Check if the nonraid module is loaded, and load it if superblock is provided
check_module_loaded() {
    local superblock="${SUPERBLOCK_PATH:-$DEFAULT_SUPERBLOCK}"
    local is_create_command=0

    # Check if we're being called as part of the create command
    local call_stack="${FUNCNAME[*]}"
    if [[ "$call_stack" == *"create_array"* ]]; then
        is_create_command=1
    fi

    # Check if module is already loaded
    if lsmod | grep -q nonraid; then
        # For create_array, verify the module is using the correct superblock
        if [ "$is_create_command" -eq 1 ] && [ -f /proc/nmdstat ]; then
            # Get all nmdstat values if we haven't already
            if [ ${#NMDSTAT_VALUES[@]} -eq 0 ]; then
                get_all_nmdstat_values NMDSTAT_VALUES
            fi
            local current_superblock="${NMDSTAT_VALUES[sbName]}"

            # If the current superblock doesn't match what we want to use
            if [ "$current_superblock" != "$superblock" ] && [ -n "$current_superblock" ] && [ "$current_superblock" != "(null)" ]; then
                echo -e "${RED}Error: NonRAID module is loaded with a different superblock${NC}"
                echo -e "Currently loaded with: ${YELLOW}$current_superblock${NC}"
                echo -e "Attempting to create array with: ${YELLOW}$superblock${NC}"
                echo -e ""
                echo -e "This could accidentally modify the wrong superblock file."
                echo -e "Explicitly reload the module with the new superblock with: ${YELLOW}nmdctl --super $superblock reload${NC}"
                return 1
            fi
        fi

        return 0
    fi

    # Module not loaded, attempt to load it
    # For create command, we can accept non-existent superblock files
    if [ -f "$superblock" ] || [ "$is_create_command" -eq 1 ]; then
        echo -e "${YELLOW}NonRAID module not loaded, attempting to load with superblock: $superblock${NC}"

        # For create command with new superblock, provide info
        if [ ! -f "$superblock" ] && [ "$is_create_command" -eq 1 ]; then
            echo -e "${YELLOW}Note: Superblock file '$superblock' doesn't exist yet${NC}"
            echo -e "${YELLOW}A new superblock will be created when the array is started${NC}"
        fi

        if ! modprobe nonraid super="$superblock"; then
            echo -e "${RED}Error: Failed to load nonraid module${NC}"
            return 1
        fi
        echo -e "${GREEN}Successfully loaded nonraid module${NC}"
        return 0
    else
        echo -e "${RED}Error: nonraid module is not loaded${NC}"
        echo -e "Superblock file not found: $superblock"
        echo -e "To create an array with this new superblock, run: ${YELLOW}nmdctl --super $superblock create${NC}"
        return 1
    fi
}

# Check if /proc/nmdstat exists
check_nmdstat_exists() {
    if [ ! -f /proc/nmdstat ]; then
        # Clear the NMDSTAT_VALUES array since /proc/nmdstat doesn't exist
        for key in "${!NMDSTAT_VALUES[@]}"; do
            unset 'NMDSTAT_VALUES["$key"]'
        done

        # Try to load the module first if it's not loaded
        if ! lsmod | grep -q nonraid; then
            check_module_loaded
        fi

        # Check again after attempted load
        if [ ! -f /proc/nmdstat ]; then
            echo -e "${RED}Error: /proc/nmdstat not found${NC}"
            echo -e "Please ensure the nonraid module is properly loaded"
            return 1
        fi
    fi
    return 0
}

# Get all values from nmdstat and store them in an associative array
# Usage: get_all_nmdstat_values nmdstat_array
# Afterward, access values with ${nmdstat_array["key"]}
get_all_nmdstat_values() {
    local -n array_ref=$1

    # Clear the array first
    for key in "${!array_ref[@]}"; do
        unset 'array_ref["$key"]'
    done

    # Read all values from /proc/nmdstat
    while IFS='=' read -r key value; do
        array_ref["$key"]="$value"
    done < <(cat /proc/nmdstat 2>/dev/null)

    # Return success only if we read something
    [ ${#array_ref[@]} -gt 0 ]
}

# Get value from nmdstat (for backward compatibility)
get_nmdstat_value() {
    grep -E "^$1=" /proc/nmdstat | cut -d= -f2
}

# Format disk status with color - returns colored text with consistent visible width
format_disk_status() {
    local status="$1"
    case "$status" in
        "DISK_OK")
            echo -e "${GREEN}OK${NC}"
            ;;
        "DISK_INVALID")
            echo -e "${RED}INVALID${NC}"
            ;;
        "DISK_NP_MISSING")
            echo -e "${YELLOW}MISSING${NC}"
            ;;
        "DISK_WRONG")
            echo -e "${RED}WRONG${NC}"
            ;;
        "DISK_DSBL"|"DISK_NP_DSBL"|"DISK_DSBL_NEW")
            echo -e "${YELLOW}DISABLED${NC}"
            ;;
        "DISK_NEW")
            echo -e "${BLUE}NEW${NC}"
            ;;
        *)
            echo -e "${YELLOW}$status${NC}"
            ;;
    esac
}

# Format array state with color
format_array_state() {
    local state="$1"
    case "$state" in
        "STARTED")
            echo -e "${GREEN}$state${NC}"
            ;;
        "STOPPED")
            echo -e "${YELLOW}$state${NC}"
            ;;
        "NEW_ARRAY")
            echo -e "${BLUE}$state${NC}"
            ;;
        "RECON_DISK"|"DISABLE_DISK"|"SWAP_DSBL")
            echo -e "${YELLOW}$state${NC}"
            ;;
        "ERROR:"*)
            echo -e "${RED}$state${NC}"
            ;;
        *)
            echo "$state"
            ;;
    esac
}

# Get count of defined disk slots in the array
# Returns the count of all slots with a defined disk
get_defined_slots_count() {
    # If NMDSTAT_VALUES is empty, populate it first
    if [ ${#NMDSTAT_VALUES[@]} -eq 0 ]; then
        get_all_nmdstat_values NMDSTAT_VALUES
    fi

    local count=0
    # Count all keys matching diskId.X with non-empty values
    for key in "${!NMDSTAT_VALUES[@]}"; do
        if [[ $key =~ ^diskId\.[0-9]+$ ]] && [ -n "${NMDSTAT_VALUES[$key]}" ]; then
            count=$((count + 1))
        fi
    done

    echo "$count"
}

# Get array of defined slot numbers
# Returns space-separated list of slot numbers that have disks defined
get_defined_slots() {
    # If NMDSTAT_VALUES is empty, populate it first
    if [ ${#NMDSTAT_VALUES[@]} -eq 0 ]; then
        get_all_nmdstat_values NMDSTAT_VALUES
    fi

    local slots=()
    # Extract slot numbers for keys matching diskId.X with non-empty values
    for key in "${!NMDSTAT_VALUES[@]}"; do
        if [[ $key =~ ^diskId\.([0-9]+)$ ]] && [ -n "${NMDSTAT_VALUES[$key]}" ]; then
            slots+=("${BASH_REMATCH[1]}")
        fi
    done

    # Sort the slots numerically and output as space-separated list
    printf "%s\n" "${slots[@]}" | sort -n | tr '\n' ' '
}

# Format time duration in seconds to a human-readable format (HH:MM:SS)
format_time_duration() {
    local seconds=$1
    local days=$(( seconds / 86400 ))
    local hours=$(( (seconds % 86400) / 3600 ))
    local minutes=$(( (seconds % 3600) / 60 ))
    local secs=$(( seconds % 60 ))

    if [ "$days" -gt 0 ]; then
        printf "%d days, %d hours" "$days" "$hours"
    elif [ "$hours" -gt 0 ]; then
        printf "%d hours, %02d minutes" "$hours" "$minutes"
    elif [ "$minutes" -gt 0 ]; then
        printf "%d minutes, %02d seconds" "$minutes" "$secs"
    else
        printf "%d sec" "$secs"
    fi
}

# Show array summary information (state, label, superblock, disks present)
show_array_summary() {
    local mdstate="${NMDSTAT_VALUES[mdState]}"
    local sblabel="${NMDSTAT_VALUES[sbLabel]}"
    local sbname="${NMDSTAT_VALUES[sbName]}"
    local mdnumdisks="${NMDSTAT_VALUES[mdNumDisks]}"

    echo -e "Array State   : $(format_array_state "$mdstate")"
    [ -n "$sblabel" ] && echo -e "Array Label   : $sblabel"

    # Check if superblock is valid
    if [ "$sbname" = "(null)" ]; then
        echo -e "Superblock    : ${RED}INVALID${NC}"
        echo -e "${YELLOW}Warning: Module loaded without specifying superblock.${NC}"
        echo -e "${YELLOW}Use '${GREEN}nmdctl --super /path/to/superblock.dat reload${YELLOW}' to reload with valid superblock.${NC}"
    else
        echo -e "Superblock    : $sbname"
    fi

    echo -e "Disks Present : $mdnumdisks"
}

# Determine array health status based on various conditions
determine_array_health() {
    local mdstate="${NMDSTAT_VALUES[mdState]}"
    local mdnummissing="${NMDSTAT_VALUES[mdNumMissing]}"
    local mdnuminvalid="${NMDSTAT_VALUES[mdNumInvalid]}"
    local mdnumwrong="${NMDSTAT_VALUES[mdNumWrong]}"
    local mdnumdisabled="${NMDSTAT_VALUES[mdNumDisabled]}"
    local mdnumreplaced="${NMDSTAT_VALUES[mdNumReplaced]}"
    local mdnumnew="${NMDSTAT_VALUES[mdNumNew]}"

    local sbsynced="${NMDSTAT_VALUES[sbSynced]}"
    local sbsynced2="${NMDSTAT_VALUES[sbSynced2]}"
    local sbsyncerrs="${NMDSTAT_VALUES[sbSyncErrs]}"
    local sbsyncexit="${NMDSTAT_VALUES[sbSyncExit]}"

    local health_status=""
    local health_details=""

    # Count the total number of disk slots that are defined in the array
    local total_slots=$(get_defined_slots_count)

    # Count how many disks have been imported
    # and how many read/write errors there are
    local imported_disks=0
    local disks_num_errors=0
    for slot in $(get_defined_slots); do
        local rdevname="${NMDSTAT_VALUES[rdevName.$slot]}"
        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            imported_disks=$((imported_disks + 1))
        fi
        disks_num_errors=$((disks_num_errors + "${NMDSTAT_VALUES[rdevNumErrors.$slot]}"))
    done

    local last_sync="never"
    # When did the last sync operation end
    if [ "$sbsynced2" != "0" ]; then
        last_sync_ago=$(($(printf "%(%s)T")-sbsynced2))
        last_sync="$(format_time_duration "$last_sync_ago") ago"
        if [ "$last_sync_ago" -gt 2592000 ]; then
            last_sync="${YELLOW}$last_sync${NC} (more than 30 days)"
        fi
        if [ "$sbsyncexit" -gt 0 ]; then
            last_sync="$last_sync ${RED}(errors encountered)${NC}"
        fi
    elif [ "$sbsynced" != "0" ]; then
        last_sync="in progress"
    fi

    local return_code=1
    # Check for critical error conditions first
    if [[ "$mdstate" = "ERROR:"* ]]; then
        health_status="${RED}ERROR${NC}"
        health_details="Array is in ERROR state"
    # Check if this is a new array
    elif [ "$mdstate" = "NEW_ARRAY" ]; then
        health_status="${BLUE}NEW${NC}"
        health_details="New array, parity needs to be built"
    # Check if a new disk is added (driver only supports one new disk at a time)
    elif [ -n "$mdnumnew" ] && [ "$mdnumnew" -gt 0 ]; then
        health_status="${BLUE}NEW_DISK${NC}"
        health_details="New disk added to the array"
    # Check if no disks have been imported yet
    elif [ "$imported_disks" -eq 0 ] && [ "$total_slots" -gt 0 ]; then
        health_status="${RED}OFFLINE${NC}"
        health_details="No disks imported"
    # Check if not all disks are imported
    elif [ "$imported_disks" -lt "$total_slots" ]; then
        health_status="${YELLOW}PARTIAL${NC}"
        health_details="$imported_disks/$total_slots disks imported"
    # Check for standard degraded conditions
    elif [ "$mdnummissing" -gt 0 ] || [ "$mdnuminvalid" -gt 0 ] ||
         [ "$mdnumwrong" -gt 0 ] || [ "$mdnumdisabled" -gt 0 ] ||
         [ "$mdnumreplaced" -gt 0 ] || [ "$sbsyncerrs" -gt 0 ] ||
         [ "$sbsyncexit" -gt 0 ]; then
        health_status="${YELLOW}DEGRADED${NC}"

        local issues=""
        [ "$mdnummissing" -gt 0 ] && issues="${issues}Missing: $mdnummissing, "
        [ "$mdnuminvalid" -gt 0 ] && issues="${issues}Invalid: $mdnuminvalid, "
        [ "$mdnumwrong" -gt 0 ] && issues="${issues}Wrong: $mdnumwrong, "
        [ "$mdnumdisabled" -gt 0 ] && issues="${issues}Disabled: $mdnumdisabled, "
        [ "$mdnumreplaced" -gt 0 ] && issues="${issues}Replaced: $mdnumreplaced, "
        [ "$sbsyncerrs" -gt 0 ] && issues="${issues}Sync Errors: $sbsyncerrs, "
        # Remove trailing comma and space
        health_details=${issues%, }
    # Check if array is stopped but healthy
    elif [ "$disks_num_errors" -gt 0 ]; then
        health_status="${YELLOW}WARNING${NC}"
        health_details="All disks present, but some have read or write errors ($disks_num_errors total)"
    elif [ "$mdstate" = "STOPPED" ]; then
        health_status="${YELLOW}READY${NC}"
        health_details="All disks imported but array is not started"
    # Everything is good!
    else
        health_status="${GREEN}HEALTHY${NC}"
        health_details="All disks present and functioning"
        return_code=0
    fi

    # Display the health status
    echo -n -e "Array Health  : $health_status"
    if [ -n "$health_details" ]; then
        echo -e " ($health_details)"
    else
        echo ""
    fi
    echo -e "Array Checked : $last_sync"

    return $return_code
}

# Show current array status
show_status() {
    if ! check_nmdstat_exists; then
        return 1
    fi

    echo "=== NonRAID Array Status ==="
    echo ""

    # Get all values from nmdstat in one go
    get_all_nmdstat_values NMDSTAT_VALUES

    # Show array summary (state, label, superblock, disks present)
    show_array_summary

    # Show array health status
    determine_array_health
    local array_health=$?

    # Show array size and parity information
    show_array_size_and_parity

    # Show resync operation status if any
    show_resync_status

    # Show disk status
    show_disk_status

    return $array_health
}

# Display array size and parity information
show_array_size_and_parity() {
    local has_parity=false
    local has_second_parity=false
    local data_size_gb=0
    local parity_size_gb=0
    local second_parity_size_gb=0

    # Check slots 0 and 29 for parity disks
    local parity_disk_size="${NMDSTAT_VALUES[diskSize.0]}"
    if [ -n "$parity_disk_size" ] && [ "$parity_disk_size" -gt 0 ]; then
        has_parity=true
        parity_size_gb=$(( (parity_disk_size + 1048575) / 1048576 ))
    fi

    # Check P state
    local parity_disk_status="${NMDSTAT_VALUES[rdevStatus.0]}"
    if [[ "$parity_disk_status" == DISK_NP* ]] || [ "$parity_disk_status" = "DISK_DSBL_NEW" ] || [ "$parity_disk_status" = "DISK_INVALID" ]; then
        # P missing or new, don't count it yet
        has_parity=false
    fi

    local second_parity_disk_size="${NMDSTAT_VALUES[diskSize.29]}"
    if [ -n "$second_parity_disk_size" ] && [ "$second_parity_disk_size" -gt 0 ]; then
        has_second_parity=true
        second_parity_size_gb=$(( (second_parity_disk_size + 1048575) / 1048576 ))
    fi

    # Check Q state
    local second_parity_disk_status="${NMDSTAT_VALUES[rdevStatus.29]}"
    if [[ "$second_parity_disk_status" == DISK_NP* ]] || [ "$second_parity_disk_status" = "DISK_DSBL_NEW" ] || [ "$second_parity_disk_status" = "DISK_INVALID" ]; then
        # Q missing or new, don't count it yet
        has_second_parity=false
    fi

    # Count data disks and sum their sizes
    local data_disk_count=0
    for slot in $(seq 1 28); do
        local disk_size="${NMDSTAT_VALUES[diskSize.$slot]}"
        if [ -n "$disk_size" ] && [ "$disk_size" -gt 0 ]; then
            data_disk_count=$((data_disk_count + 1))
            data_size_gb=$((data_size_gb + (disk_size + 1048575) / 1048576))
        fi
    done

    # Display array size information
    echo -e "Array Size    : ${data_size_gb} GB (${data_disk_count} data disk(s))"

    # Display parity protection information
    echo -n "Parity        : "
    if $has_parity && $has_second_parity; then
        echo -e "${GREEN}Dual Parity${NC} (P: ${parity_size_gb} GB, Q: ${second_parity_size_gb} GB)"
    elif $has_parity; then
        echo -e "${GREEN}Single Parity${NC} (${parity_size_gb} GB)"
    else
        echo -e "${YELLOW}No Parity${NC}"
    fi
}

# Display resync operation status (reconstruction, clearing, check)
show_resync_status() {
    local mdresync="${NMDSTAT_VALUES[mdResync]}"
    local mdresyncaction="${NMDSTAT_VALUES[mdResyncAction]}"
    local mdresynccorr="${NMDSTAT_VALUES[mdResyncCorr]}"

    # Check for pending disk clearing
    if [ "$mdresync" = "0" ] && [ "$mdresyncaction" = "clear" ]; then
        echo ""
        echo -e "${YELLOW}Disk clearing pending: New disk needs to be cleared${NC}"
        echo -e "${YELLOW}Start the array and use '${GREEN}nmdctl check${YELLOW}' command to start the disk clear${NC}"
    # Check for pending reconstruction
    elif [ "$mdresync" = "0" ] && [[ "$mdresyncaction" == recon* ]]; then
        echo ""
        echo -e "${YELLOW}Disk reconstruction pending: ${BLUE}$mdresyncaction${NC}"
        echo -e "${YELLOW}Start the array and use '${GREEN}nmdctl check${YELLOW}' command to start the reconstruction${NC}"
    # Check for active reconstruction or check operation
    elif [ "$mdresync" != "0" ] && [ -n "$mdresync" ]; then
        local mdresyncpos="${NMDSTAT_VALUES[mdResyncPos]}"
        local mdresyncsize="${NMDSTAT_VALUES[mdResyncSize]}"
        local mdresyncdt="${NMDSTAT_VALUES[mdResyncDt]}"
        local mdresyncdb="${NMDSTAT_VALUES[mdResyncDb]}"

        local corr="(correcting)"
        # Check or correction operation
        if [ "$mdresynccorr" = "0" ]; then
            corr="(check only)"
        fi

        # Calculate progress percentage
        local progress=0
        if [ "$mdresyncsize" -gt 0 ]; then
            progress=$(( mdresyncpos * 100 / mdresyncsize ))
        fi

        # Calculate rate (blocks per second)
        local rate=0
        if [ "$mdresyncdt" -gt 0 ]; then
            rate=$(( mdresyncdb / mdresyncdt ))
        fi

        # Convert rate from KB/s to MB/s (using bash arithmetic for compatibility)
        local rate_mb_int=$(( rate * 100 / 1024 ))
        local rate_mb_whole=$(( rate_mb_int / 100 ))
        local rate_mb_frac=$(( rate_mb_int % 100 ))
        local rate_mb="${rate_mb_whole}.$(printf "%02d" $rate_mb_frac)"

        # Calculate elapsed time (mdResyncDt is in seconds)
        local elapsed_time=$mdresyncdt
        local elapsed_formatted=$(format_time_duration "$elapsed_time")

        # Calculate estimated time remaining
        local eta_seconds=0
        if [ "$rate" -gt 0 ] && [ "$mdresyncsize" -gt "$mdresyncpos" ]; then
            local remaining_blocks=$(( mdresyncsize - mdresyncpos ))
            eta_seconds=$(( remaining_blocks / rate ))
        fi
        local eta_formatted=$(format_time_duration $eta_seconds)

        echo ""
        echo -e "Operation     : ${BLUE}$mdresyncaction${NC} $corr"
        echo -e "Progress      : $progress% ($mdresyncpos/$mdresyncsize blocks)"
        echo -e "Speed         : $rate_mb MB/s"
        echo -e "Elapsed Time  : $elapsed_formatted"
        echo -e "ETA           : $eta_formatted"
    fi
}

# Calculate visible length of disk status for alignment
get_status_visible_length() {
    local status="$1"

    case "$status" in
        "DISK_OK")
            echo "2" # "OK"
            ;;
        "DISK_INVALID")
            echo "7" # "INVALID"
            ;;
        "DISK_NP_MISSING")
            echo "7" # "MISSING"
            ;;
        "DISK_WRONG")
            echo "5" # "WRONG"
            ;;
        "DISK_DSBL"|"DISK_NP_DSBL"|"DISK_DSBL_NEW")
            echo "8" # "DISABLED"
            ;;
        "DISK_NEW")
            echo "3" # "NEW"
            ;;
        *)
            echo "${#status}" # Use raw length as fallback
            ;;
    esac
}

# Format and display a single disk entry in the array
display_disk_entry() {
    local idx="$1"
    local slottype="$2"
    local disksize="$3"
    local diskid="$4"
    local rdevname="$5"
    local rdevstatus="$6"
    local rdevnumerrors="${7:-0}"
    local diskname="$8"
    local mdstate="$9"
    local fs_type=""

    # Convert size to GB
    local sizegb=0
    if [ -n "$disksize" ] && [ "$disksize" -gt 0 ]; then
        sizegb=$(( (disksize + 1048575) / 1048576 ))
    fi

    local status_formatted=$(format_disk_status "$rdevstatus")

    # Map status to visible text length for alignment
    local visible_length=$(get_status_visible_length "$rdevstatus")

    # Add indicator for disk errors
    if [ -n "$rdevnumerrors" ] && [ "$rdevnumerrors" -gt 0 ]; then
        status_formatted="$status_formatted $(echo -e "${RED}($rdevnumerrors errs)${NC}")"
        # Account for the extra text in the visible length
        visible_length=$((visible_length + ${#rdevnumerrors} + 8))
    fi

    # Fix alignment with proper field widths - split into parts to handle color codes
    printf "%-4s  " "${slottype:-$idx}"
    printf "%s" "$status_formatted"
    printf "%$((21 - visible_length))s" " " # Use visible length for padding

    if [ "$mdstate" = "STARTED" ]; then
        local mountpoint=""
        local usage="-"
        local fs_type=""

        [ -n "$slottype" ] && mountpoint="-"
        # Get filesystem type and mountpoint for data disks when array is started
        if [ -n "$diskname" ] && [ "$diskname" != "none" ]; then
            # Check if device exists before calling blkid
            if [ -b "/dev/$diskname" ]; then
                fs_type=$(get_fs_type "/dev/$diskname")
                # Get mountpoint if we have a filesystem
                if [ -n "$fs_type" ] && [ "$fs_type" != "unknown" ]; then
                    mountpoint=$(get_mountpoint "$diskname" "$fs_type")
                    # Get usage percentage if mounted
                    if [ "$mountpoint" != "unmounted" ] && [ "$mountpoint" != "-" ]; then
                        usage=$(get_fs_usage "$mountpoint" "$fs_type")
                    fi
                else
                    mountpoint="unmounted"
                fi
            fi
        fi

        # Include disk name, filesystem, mountpoint and usage columns when array is started
        if [ "$VERBOSE" -eq 1 ]; then
            # Show drive ID when verbose mode is enabled
            printf "%-10s  %-8s  %-10s  %-12s  %-16s  %-8s  %s\n" "${rdevname:-none}" "$disksize" "${diskname:-${slottype:-$idx}}" "${fs_type:-$slottype}" "${mountpoint:-unmounted}" "$usage" "$diskid"
        else
            # Omit drive ID in normal mode
            printf "%-10s  %-8s  %-10s  %-12s  %-16s  %-8s\n" "${rdevname:-none}" "$sizegb" "${diskname:-${slottype:-$idx}}" "${fs_type:-$slottype}" "${mountpoint:-unmounted}" "$usage"
        fi
    else
        # Original format without disk name and filesystem
        if [ "$VERBOSE" -eq 1 ]; then
            # Show drive ID when verbose mode is enabled
            printf "%-10s  %-8s  %s\n" "${rdevname:-none}" "$disksize" "$diskid"
        else
            # Omit drive ID in normal mode
            printf "%-10s  %-8s\n" "${rdevname:-none}" "$sizegb"
        fi
    fi
}

# Display all disks in the array
show_disk_status() {
    local mdstate="${NMDSTAT_VALUES[mdState]}"

    echo ""
    echo "=== Disk Status ==="
    echo ""

    if [ "$mdstate" = "STARTED" ]; then
        if [ "$VERBOSE" -eq 1 ]; then
            echo -e "Slot  Status               Device      Size(1k)  Disk Name   FS            Mountpoint        Usage     Drive ID"
            echo -e "----  -------------------  ----------  --------  ----------  ------------  ---------------   --------  -------------------------------------"
        else
            echo -e "Slot  Status               Device      Size(GB)  Disk Name   FS            Mountpoint        Usage"
            echo -e "----  -------------------  ----------  --------  ----------  ------------  ---------------   --------"
        fi
    else
        if [ "$VERBOSE" -eq 1 ]; then
            echo -e "Slot  Status               Device      Size(1k)  Drive ID"
            echo -e "----  -------------------  ----------  --------  -------------------------------------"
        else
            echo -e "Slot  Status               Device      Size(GB)"
            echo -e "----  -------------------  ----------  --------"
        fi
    fi

    # Special handling for parity disks
    for idx in 0 29; do
        local diskname="${NMDSTAT_VALUES[diskName.$idx]}"
        local diskid="${NMDSTAT_VALUES[diskId.$idx]}"
        local rdevstatus="${NMDSTAT_VALUES[rdevStatus.$idx]}"

        # Always display P, display Q if it has an ID OR it's a newly assigned disk (DISK_*_NEW)
        if [ "$idx" -eq 0 ] || [ -n "$diskid" ] || [[ "$rdevstatus" == DISK_*_NEW ]]; then
            local disksize="${NMDSTAT_VALUES[diskSize.$idx]}"
            local rdevname="${NMDSTAT_VALUES[rdevName.$idx]}"
            local rdevnumerrors="${NMDSTAT_VALUES[rdevNumErrors.$idx]}"

            # For DISK_NEW, get size from rdevSize instead of diskSize
            if [[ ("$rdevstatus" = "DISK_NEW" || "$rdevstatus" = "DISK_DSBL_NEW") ]] && { [ -z "$disksize" ] || [ "$disksize" = "0" ]; }; then
                local rdevsize="${NMDSTAT_VALUES[rdevSize.$idx]}"
                if [ -n "$rdevsize" ] && [ "$rdevsize" -gt 0 ]; then
                    disksize="$rdevsize"
                fi

                # If diskId is empty but rdevId exists, use that
                if [ -z "$diskid" ]; then
                    diskid="${NMDSTAT_VALUES[rdevId.$idx]}"
                fi
            fi

            local slottype=""
            if [ "$idx" -eq 0 ]; then
                slottype="P"
            elif [ "$idx" -eq 29 ]; then
                slottype="Q"
            fi

            if [ -n "$rdevstatus" ]; then
                display_disk_entry "$idx" "$slottype" "$disksize" "$diskid" "$rdevname" "$rdevstatus" "$rdevnumerrors" "$diskname" "$mdstate"
            fi
        fi
    done

    # Now list data disks
    for idx in $(seq 1 28); do
        local diskname="${NMDSTAT_VALUES[diskName.$idx]}"
        local rdevstatus="${NMDSTAT_VALUES[rdevStatus.$idx]}"

        # Display disk if it has a name OR it's a newly assigned disk (DISK_NEW)
        if [ -n "$diskname" ] || [ "$rdevstatus" = "DISK_NEW" ]; then
            local disksize="${NMDSTAT_VALUES[diskSize.$idx]}"
            local diskid="${NMDSTAT_VALUES[diskId.$idx]}"
            local rdevname="${NMDSTAT_VALUES[rdevName.$idx]}"
            local rdevnumerrors="${NMDSTAT_VALUES[rdevNumErrors.$idx]}"

            # For DISK_NEW, get size from rdevSize instead of diskSize
            if [ "$rdevstatus" = "DISK_NEW" ] && { [ -z "$disksize" ] || [ "$disksize" = "0" ]; }; then
                local rdevsize="${NMDSTAT_VALUES[rdevSize.$idx]}"
                if [ -n "$rdevsize" ] && [ "$rdevsize" -gt 0 ]; then
                    disksize="$rdevsize"
                fi

                # If diskId is empty but rdevId exists, use that
                if [ -z "$diskid" ]; then
                    diskid="${NMDSTAT_VALUES[rdevId.$idx]}"
                fi
            fi

            display_disk_entry "$idx" "" "$disksize" "$diskid" "$rdevname" "$rdevstatus" "$rdevnumerrors" "$diskname" "$mdstate"
        fi
    done

    return 0
}

# Get filesystem type for a device using blkid
get_fs_type() {
    local device="$1"

    if [ -b "$device" ]; then
        # Run blkid to get the filesystem type
        local fs_type=$(blkid -o value -s TYPE "$device" 2>/dev/null)

        # Convert zfs_member to just zfs
        if [ "$fs_type" = "zfs_member" ]; then
            echo "zfs"
        elif [ "$fs_type" = "crypto_LUKS" ]; then
            local luks_fs="$(get_fs_type "/dev/mapper/$(basename "$device")")"
            if [ -z "$luks_fs" ]; then
                echo "luks"
            else
                echo "luks+$luks_fs"
            fi
        else
            echo "${fs_type:-unknown}"
        fi
        return 0
    fi

    echo ""
    return 1
}

# Get mountpoint for a device
# supports both relative and absolute device names
get_mountpoint() {
    local device="$1"
    local fs_type="$2"

    # Default to unmounted
    local mountpoint="unmounted"

    if [ -z "$device" ] || [ "$device" = "none" ]; then
        echo "$mountpoint"
        return 0
    fi

    # Handle different filesystem types
    case "$fs_type" in
        luks\+*)
            # For LUKS, we need to check the underlying filesystem
            local luks_fs=$(echo "$fs_type" | cut -d'+' -f2)
            if [ -n "$luks_fs" ]; then
                mountpoint=$(get_mountpoint "/dev/mapper/$device" "$luks_fs")
            fi
            ;;
        "xfs"|"ext4"|"ext3"|"ext2"|"btrfs")
            # These filesystems can be found directly in /proc/mounts
            local abs_device=$device
            [[ "$device" != /dev/* ]] && abs_device="/dev/$device"
            local found_mountpoint=$(grep -w "$abs_device" /proc/mounts | awk '{print $2}' | head -1)
            if [ -n "$found_mountpoint" ]; then
                mountpoint="$found_mountpoint"
            fi
            ;;

        "zfs")
            # For ZFS, we need to identify the pool name and dataset
            # Get ZFS pool name that contains this device
            if command -v zpool >/dev/null 2>&1; then
                local rel_device=$(basename "$device")
                local pool=$(zpool list -H -o name,health | awk '{print $1}' | while read -r pool; do
                    if zpool status "$pool" 2>/dev/null | grep -q "$rel_device"; then
                        echo "$pool"
                        break
                    fi
                done)

                if [ -n "$pool" ]; then
                    # Check if the pool is mounted
                    local zfs_mounts=$(zfs list -H -o name,mountpoint | grep -v "none$")
                    # Start with the pool itself
                    local found_mountpoint=$(echo "$zfs_mounts" | grep "^${pool}[[:blank:]]" | awk '{print $2}' | head -1)

                    if [ -n "$found_mountpoint" ] && [ "$found_mountpoint" != "none" ]; then
                        mountpoint="$found_mountpoint"
                    fi
                fi
            fi
            ;;

        *)
            # Generic approach for other filesystem types
            local abs_device="$device"
            [[ "$device" != /dev/* ]] && abs_device="/dev/$device"
            local found_mountpoint=$(grep -w "$abs_device" /proc/mounts 2>/dev/null | awk '{print $2}' | head -1)
            if [ -n "$found_mountpoint" ]; then
                mountpoint="$found_mountpoint"
            fi
            ;;
    esac

    echo "$mountpoint"
    return 0
}

# Get filesystem usage percentage
get_fs_usage() {
    local mountpoint="$1"
    local fs_type="$2"

    # If not mounted or invalid mountpoint, return empty
    if [ "$mountpoint" = "unmounted" ] || [ "$mountpoint" = "-" ] || [ ! -d "$mountpoint" ]; then
        echo "-"
        return 0
    fi

    # Handle different filesystem types
    case "$fs_type" in
        "zfs")
            # For ZFS, we need to use zfs command to get usage
            if command -v zfs >/dev/null 2>&1; then
                # Extract pool/dataset name from the mountpoint
                local dataset=$(zfs list -H -o name,mountpoint | grep "[[:space:]]$mountpoint$" | awk '{print $1}' | head -1)
                if [ -n "$dataset" ]; then
                    # Use zfs get to get the percentage directly
                    local usage=$(zpool list -H -o cap "$dataset" 2>/dev/null)
                    if [ -n "$usage" ]; then
                        echo "$usage"
                        return 0
                    fi
                fi
            fi
            ;;

        *)
            # Generic approach using df for standard filesystems
            if command -v df >/dev/null 2>&1; then
                local usage=$(df -h "$mountpoint" 2>/dev/null | tail -n 1 | awk '{ print $5 }')
                if [ -n "$usage" ]; then
                    echo "$usage"
                    return 0
                fi
            fi
            ;;
    esac

    echo "-"
    return 0
}

# Get disk size in 1K blocks
get_disk_size_kb() {
    local device="$1"
    if [ ! -b "$device" ]; then
        return 1
    fi

    # Use blockdev to get exact size in 512-byte logical sectors
    local sectors=$(blockdev --getsz "$device" 2>/dev/null)
    if [ -n "$sectors" ]; then
        # Round down to nearest multiple of 8 sectors (driver reads/writes 8 sectors at a time)
        local adjusted_sectors=$(( (sectors / 8) * 8 ))
        # Convert to 1K blocks (2 sectors = 1KB)
        local kb_size=$(( adjusted_sectors / 2 ))
        echo "$kb_size"
        return 0
    fi
    return 1
}

# Find disk device name matching the ID in nmdstat
find_matching_disk() {
    local disk_id="$1"

    # Check if disk_id is empty
    if [ -z "$disk_id" ]; then
        return 1
    fi

    # Look through /dev/disk/by-id to find matching disk
    if [ -d "/dev/disk/by-id" ]; then
        for id_path in /dev/disk/by-id/*; do
            # Skip if not a symlink or if it's a partition
            if [ ! -L "$id_path" ] || [[ "$id_path" == *-part* ]]; then
                continue
            fi

            local id_name=$(basename "$id_path")
            # If the disk ID contains the target ID, consider it a match
            if [[ "$id_name" == *"$disk_id"* ]]; then
                # Get the actual device the symlink points to
                local real_dev=$(readlink -f "$id_path")
                echo "$real_dev"
                return 0
            fi
        done
    fi

    return 1
}

# Import disks to array without starting it
import_disks() {
    check_root

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    echo "Scanning array configuration..."

    # Parse superblock to get disk IDs and slot assignments
    local num_disks=0
    local disks_to_import=()

    # Process all defined disk slots
    for slot in $(get_defined_slots); do
        local disk_id=$(get_nmdstat_value "diskId.$slot")

        # Check if this slot already has a device imported
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            echo -e "${YELLOW}Skipping slot $slot: Already has device $rdevname imported${NC}"
            continue
        fi

        # Check if this slot has been intentionally disabled (DISK_NP_MISSING status)
        local rdevstatus=$(get_nmdstat_value "rdevStatus.$slot")
        if [ "$rdevstatus" = "DISK_NP_MISSING" ]; then
            echo -e "${YELLOW}Skipping slot $slot: Disk has been unassigned (status: $rdevstatus)${NC}"
            continue
        fi

        # Find matching physical disk
        local found_device=""
        if [ -d "/dev/disk/by-id" ]; then
            found_device=$(find_matching_disk "$disk_id")
        fi

        # Check if device exists and has a first partition
        local partition=""
        if [ -n "$found_device" ]; then
            # Check for partitions
            if [ -b "${found_device}1" ]; then
                partition="${found_device}1"
            elif [ -b "${found_device}p1" ]; then
                partition="${found_device}p1"
            fi

            if [ -n "$partition" ]; then
                # Get the partition size
                local disk_size=$(get_disk_size_kb "$partition")

                if [ -n "$disk_size" ]; then
                    # Get the configured size from nmdstat
                    local configured_size=$(get_nmdstat_value "diskSize.$slot")
                    local size_to_use="$disk_size"

                    # If we have a configured size and it differs from actual size
                    if [ -n "$configured_size" ] && [ "$configured_size" -gt 0 ] && [ "$configured_size" -ne "$disk_size" ]; then
                        echo -e "${YELLOW}Warning: Size mismatch for disk in slot $slot${NC}"
                        echo -e "  Partition size: $disk_size KB"
                        echo -e "  Expected size : $configured_size KB"

                        if [ "$UNATTENDED" -eq 1 ]; then
                            # If unattended, do not continue import
                            echo -e "${RED}Error: Size mismatch for disk in slot $slot (unattended mode)${NC}"
                            continue
                        fi

                        # Ask for confirmation
                        read -r -p "Use the configured size instead of detected size? (y/N): " confirm
                        if [[ "$confirm" =~ ^[Yy]$ ]]; then
                            size_to_use="$configured_size"
                            echo -e "Using configured size: ${BLUE}$configured_size KB${NC}"
                        else
                            echo -e "Using detected partition size: ${BLUE}$disk_size KB${NC}"
                        fi
                    fi

                    echo -e "Found disk for slot $slot: ${BLUE}$(basename "$partition")${NC} (ID: ${disk_id:0:25}...)"

                    # Store partition name without /dev/
                    partition=$(basename "$partition")

                    # Add to import list: slot, partition, offset, size, erased, id
                    disks_to_import+=("$slot|$partition|0|$size_to_use|0|$disk_id")
                    num_disks=$((num_disks + 1))
                else
                    echo -e "${YELLOW}Warning: Could not determine size for $partition${NC}"
                fi
            else
                echo -e "${YELLOW}Warning: No partition found for disk $found_device${NC}"
            fi
        else
            echo -e "${YELLOW}Warning: Could not find physical disk for ID: ${disk_id:0:25}...${NC}"
        fi
    done

    # Check if we found any disks to import
    if [ "$num_disks" -eq 0 ]; then
        # Check if disks were already imported (check for any rdevName values)
        local already_imported=0
        # shellcheck disable=SC2013
        for slot in $(grep -E "^diskId\.[0-9]+" /proc/nmdstat | cut -d'.' -f2 | cut -d'=' -f1); do
            local rdevname=$(get_nmdstat_value "rdevName.$slot")
            if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
                already_imported=$((already_imported + 1))
            fi
        done

        if [ "$already_imported" -gt 0 ]; then
            echo -e "${GREEN}All disks already imported ($already_imported disk(s) found)${NC}"
        else
            echo -e "${RED}Error: No disks found to import${NC}"
            return 1
        fi
    else
        echo ""
        echo "Importing $num_disks disks..."

        # Import each disk
        for disk_data in "${disks_to_import[@]}"; do
            IFS='|' read -r slot partition offset size erased id <<< "$disk_data"

            echo -e "Importing disk to slot $slot: ${BLUE}$partition${NC}"
            if ! run_nmd_command "import $slot $partition $offset $size $erased $id"; then
                echo -e "${RED}Error: Failed to import disk to slot $slot${NC}"
            fi
        done

        echo -e "${GREEN}Successfully imported $num_disks disk(s)${NC}"
    fi

    echo ""
    # Show array status after importing
    show_status

    return 0
}

# Start the array by importing disks and starting the array
start_array() {
    check_root

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check current array state
    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" = "STARTED" ]; then
        echo -e "${YELLOW}Array is already started${NC}"
        return 0
    fi

    # Import disks first
    import_disks

    echo ""
    # Check array state after imports
    mdstate=$(get_nmdstat_value "mdState")

    # Check if all defined disks have been imported
    local imported_disks=0
    local missing_slots=()

    # Count imported disks and track which ones are missing
    for slot in $(get_defined_slots); do
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        local rdevstatus=$(get_nmdstat_value "rdevStatus.$slot")

        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            imported_disks=$((imported_disks + 1))
        elif [ "$rdevstatus" != "DISK_NP_MISSING" ]; then
            # Only consider it missing if it's not intentionally unassigned
            missing_slots+=("$slot")
        fi
    done

    # If we have missing disks that aren't explicitly unassigned, don't allow starting
    if [ ${#missing_slots[@]} -gt 0 ]; then
        echo -e "${RED}Error: Cannot start array with missing disks${NC}"
        echo -e "${YELLOW}The following disk slots are defined but not imported:${NC} ${missing_slots[*]}"
        echo -e "${YELLOW}You must either:${NC}"
        echo -e "  1. Import the missing disk(s) with ${GREEN}nmdctl import${NC}"
        echo -e "  2. Unassign the missing disk(s) with ${GREEN}nmdctl unassign SLOT${NC}"
        return 1
    fi

    # If no disks were imported, warn the user, and refuse to start in unattended mode
    if [ "$imported_disks" -eq 0 ]; then
        if [ "$UNATTENDED" -eq 1 ]; then
            echo -e "${RED}Error: No disks imported. Cannot start array (unattended mode)${NC}"
            return 1
        else
            echo -e "${YELLOW}Warning: No disks imported.${NC}"
        fi
    fi

    # Check array state and proceed based on it
    if [ "$mdstate" = "STOPPED" ]; then
        # Normal state, proceed without confirmation
        echo "Array is in normal STOPPED state"
        if ! run_nmd_command "start"; then
            echo -e "${RED}Error: Failed to start array${NC}"
            return 1
        fi
    else
        # Abnormal state, require confirmation
        echo -e "${YELLOW}Array is in abnormal state: $mdstate${NC}"

        case "$mdstate" in
            "NEW_ARRAY")
                echo -e "${YELLOW}This is a NEW_ARRAY and will require parity construction.${NC}"
                ;;
            "RECON_DISK")
                echo -e "${YELLOW}One or more disks need reconstruction.${NC}"
                ;;
            "DISABLE_DISK")
                echo -e "${YELLOW}Array will run in degraded mode with missing disk(s).${NC}"
                ;;
            "SWAP_DSBL")
                echo -e "${YELLOW}Parity disk(s) need to be rearranged.${NC}"
                ;;
            "ERROR:"*)
                echo -e "${RED}Array is in ERROR state. Starting may fail or cause data loss.${NC}"
                ;;
        esac

        if [ "$UNATTENDED" -eq 1 ]; then
            echo -e "${RED}Error: Cannot start array in abnormal state in unattended mode${NC}"
            return 1
        fi

        # Ask for confirmation
        read -r -p "Do you want to continue starting the array in this state? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "Proceeding with array start in $mdstate state"
            if ! run_nmd_command "start $mdstate"; then
                echo -e "${RED}Error: Failed to start array${NC}"
                return 1
            fi
        else
            echo "Array start cancelled by user"
            return 1
        fi
    fi

    echo -e "${GREEN}Array started successfully${NC}"
    echo ""

    # Show array status
    show_status

    return 0
}

# Stop the array
stop_array() {
    check_root

    if ! check_nmdstat_exists; then
        return 1
    fi

    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${YELLOW}Array is not running (current state: $mdstate)${NC}"
        return 0
    fi

    echo "Stopping array..."
    if ! run_nmd_command "stop"; then
        echo -e "${RED}Error: Failed to stop array${NC}"
        return 1
    fi

    echo -e "${GREEN}Array stopped successfully${NC}"
    return 0
}

# Start parity check
start_check() {
    local option="${1:-CORRECT}"
    check_root

    if ! check_nmdstat_exists; then
        return 1
    fi

    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${RED}Error: Array must be started to run parity check${NC}"
        return 1
    fi

    echo "Starting parity check with option $option..."
    if ! run_nmd_command "check $option"; then
        echo -e "${RED}Error: Failed to start parity check${NC}"
        return 1
    fi

    echo -e "${GREEN}Parity check started${NC}"
    return 0
}

# Stop parity check
stop_check() {
    local option="${1:-CANCEL}"
    check_root

    if ! check_nmdstat_exists; then
        return 1
    fi

    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${RED}Error: Array must be started to stop parity check${NC}"
        return 1
    fi

    echo "Stopping parity check with option $option..."
    if ! run_nmd_command "nocheck $option"; then
        echo -e "${RED}Error: Failed to stop parity check${NC}"
        return 1
    fi

    echo -e "${GREEN}Parity check stopped${NC}"
    return 0
}

# List available block devices with single partitions
list_available_devices() {
    local devices=()

    # Find all disk devices
    for dev in /dev/sd*; do
        # Skip if not a block device or if it's a partition
        if [ ! -b "$dev" ] || [[ "$dev" == *[0-9] ]]; then
            continue
        fi

        # Check if the device has exactly one partition
        local partition_count=$(grep -c "$(basename "${dev}")[0-9]" /proc/partitions)
        if [ "$partition_count" -eq 1 ]; then
            # Get the partition device
            local partition=""
            if [ -b "${dev}1" ]; then
                partition="${dev}1"
            elif [ -b "${dev}p1" ]; then
                partition="${dev}p1"
            else
                continue  # Skip if we can't find the partition
            fi

            # Get device details using a more reliable approach
            # Get disk ID without using xargs and pipeline
            local disk_id=""
            if [ -d "/dev/disk/by-id" ]; then
                local dev_name=$(basename "$dev")
                # Use a safer approach to find the matching disk ID
                for id_path in /dev/disk/by-id/*; do
                    if [ -L "$id_path" ] && [[ "$id_path" != *-part* ]]; then
                        local link_target=$(readlink -f "$id_path")
                        if [ "$(basename "$link_target")" = "$dev_name" ]; then
                            disk_id=$(basename "$id_path")
                            break
                        fi
                    fi
                done
            fi

            # Get disk size information
            local size_kb=$(get_disk_size_kb "$partition")
            local size_gb=0
            if [ -n "$size_kb" ] && [ "$size_kb" -gt 0 ]; then
                size_gb=$(( (size_kb + 1048575) / 1048576 ))
            fi

            # Add to available devices
            devices+=("$dev|$partition|$size_kb|$size_gb|$disk_id")
        fi
    done

    echo "${devices[@]}"
}

# Create a new array with interactive disk assignment
create_array() {
    check_root

    # Get current superblock path
    local superblock="${SUPERBLOCK_PATH:-$DEFAULT_SUPERBLOCK}"
    local is_new_superblock=0
    local do_new_config=0
    local do_parity_skip=0

    # Check if this will be a new superblock
    if [ ! -f "$superblock" ]; then
        is_new_superblock=1
        echo -e "${BLUE}Creating a new array with a new superblock at: ${GREEN}$superblock${NC}"
        echo -e "${YELLOW}Note: The superblock file will be created when the array is started${NC}"
    fi

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check if the array is already started
    local mdstate=$(get_nmdstat_value "mdState")
    if [ "$mdstate" != "STOPPED" ]; then
        echo -e "${RED}Error: The array is not currently stopped. Please stop it first.${NC}"
        return 1
    fi

    # Verify no disks are defined in the array
    local disk_count=$(get_defined_slots_count)
    if [ "$disk_count" -gt 0 ] && [ "$is_new_superblock" -eq 0 ]; then
        echo -e "${YELLOW}Warning: The array already has $disk_count disk(s) configured${NC}"
        echo ""
        read -r -p "Do you want to recreate the current array with a new config? [y/N]: " response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            get_all_nmdstat_values NMDSTAT_VALUES
            do_new_config=1
            echo -e "Saving old superblock as ${GREEN}${superblock}.bak${NC}"
            if ! mv "$superblock" "${superblock}.bak" 2>/dev/null; then
                echo -e "${RED}Error: Failed to move old superblock${NC}"
                return 1
            fi
            echo -e "${YELLOW}Reloading module with empty superblock...${NC}"
            if ! reload_module 1; then
                echo -e "${RED}Error: Failed to reload module with empty superblock - restoring old superblock and aborting${NC}"
                mv "${superblock}.bak" "$superblock" 2>/dev/null
                return 1
            fi
            echo -e "${GREEN}Module reloaded successfully${NC}"
        else
            echo "Operation cancelled."
            return 1
        fi
    fi

    echo -e "=== ${BLUE}Creating New NonRAID Array${NC} ==="
    echo ""
    echo -e "${YELLOW}This will create a new array and assign disks to slots.${NC}"
    echo -e "${YELLOW}Only devices with a single partition will be shown.${NC}"
    echo ""

    # Get available devices
    echo "Scanning for available disks..."
    local available_devices=($(list_available_devices))

    if [ ${#available_devices[@]} -eq 0 ]; then
        echo -e "${RED}Error: No suitable disk devices found${NC}"
        echo -e "${YELLOW}Make sure disks are connected and have a single partition${NC}"
        return 1
    fi

    echo -e "Found ${GREEN}${#available_devices[@]}${NC} suitable devices with partitions"
    echo ""

    # Ask for array label
    local array_label=""
    read -r -p "Enter a label for the array (optional): " array_label
    if [ -n "$array_label" ]; then
        # Defer setting the label until disks have been added to array
        echo "Will set array label to: $array_label"
    fi
    echo ""

    local assigned_slots=()
    local assigned_count=0

    # Display available slots explanation
    echo -e "${BLUE}Slot Assignment Guidelines:${NC}"
    echo -e " - Slot P (0): Parity disk (largest disk recommended)"
    echo -e " - Slot Q (29): Optional second parity for dual parity (not required)"
    echo -e " - Slots 1-28: Data disks"
    echo ""

    # Process each device
    for device_info in "${available_devices[@]}"; do
        IFS='|' read -r dev partition size_kb size_gb disk_id <<< "$device_info"

        echo -e "=== Disk: ${BLUE}$(basename "$dev")${NC} ==="
        echo -e "Partition: $(basename "$partition")"
        echo -e "Size: $size_gb GB"
        if [ -n "$disk_id" ]; then
            echo -e "ID: $disk_id"
        else
            echo -e "ID: Unknown"
        fi
        echo ""
        if [ "$do_new_config" -eq 1 ]; then
            # Check if this disk was previously assigned to the array
            local prev_slot=""
            local prev_slot_type=""
            if [ -n "$disk_id" ]; then
                # Search through all previously configured slots to find where this disk was assigned
                for check_slot in $(get_defined_slots); do
                    local check_disk_id="${NMDSTAT_VALUES[diskId.$check_slot]}"
                    if [ -n "$check_disk_id" ] && [[ "$disk_id" == *"$check_disk_id"* ]] || [[ "$check_disk_id" == *"$disk_id"* ]]; then
                        prev_slot="$check_slot"
                        if [ "$check_slot" = "0" ]; then
                            prev_slot_type="P (Parity)"
                        elif [ "$check_slot" = "29" ]; then
                            prev_slot_type="Q (Second Parity)"
                        else
                            prev_slot_type="Data"
                        fi
                        break
                    fi
                done

                if [ -n "$prev_slot" ]; then
                    echo -e "${GREEN}Previously assigned:${NC} Slot $prev_slot ($prev_slot_type)"
                    echo ""
                else
                    echo -e "${YELLOW}No previous slot assignment found for this disk${NC}"
                fi
            fi
        fi

        # Show which slots are already assigned
        if [ ${#assigned_slots[@]} -gt 0 ]; then
            echo -e "Assigned slots: ${GREEN}${assigned_slots[*]}${NC}"
            echo ""
        fi

        # Ask for slot assignment
        while true; do
            echo -e "Enter slot assignment for this disk:"
            echo -e " P or 0: Parity disk"
            echo -e " Q or 29: Second parity disk (optional)"
            echo -e " 1-28: Data disk"
            if [ "$do_new_config" -eq 1 ] && [ -n "$prev_slot" ]; then
                echo -e " o: Use old slot ($prev_slot - $prev_slot_type)"
            fi
            echo -e " s: Skip this disk"
            echo -e " f: Finish array creation"
            read -r -p "Choice: " choice

            local slot=""
            case "$choice" in
                [Pp])
                    slot="0"
                    ;;
                [Qq])
                    slot="29"
                    ;;
                [0-9]|[0-2][0-9])
                    # Check if slot is valid (0-29)
                    if [ "$choice" -ge 0 ] && [ "$choice" -le 29 ]; then
                        slot="$choice"
                    else
                        echo -e "${RED}Invalid slot number. Please use 0-29.${NC}"
                        continue
                    fi
                    ;;
                [Oo])
                    if [ "$do_new_config" -eq 1 ] && [ -n "$prev_slot" ]; then
                        slot="$prev_slot"
                        echo -e "${GREEN}Using previous slot assignment: $slot${NC}"
                    else
                        echo -e "${RED}No previous slot assigned for this disk.${NC}"
                        continue
                    fi
                    ;;
                [Ss])
                    echo -e "${YELLOW}Skipping disk ${BLUE}$(basename "$dev")${NC}"
                    break
                    ;;
                [Ff])
                    echo "Finishing array creation..."
                    break 2  # Break out of both loops
                    ;;
                *)
                    echo -e "${RED}Invalid choice. Please try again.${NC}"
                    continue
                    ;;
            esac

            if [ -n "$slot" ]; then
                # Check if slot is already assigned
                # shellcheck disable=SC2076
                if [[ " ${assigned_slots[*]} " =~ " $slot " ]]; then
                    echo -e "${RED}Error: Slot $slot is already assigned. Please choose another slot.${NC}"
                    continue
                fi

                # Import disk to slot
                echo -e "Importing disk to slot $slot: ${BLUE}$(basename "$partition")${NC}"

                # Get disk ID (use device path if no ID)
                local id_to_use="${disk_id:-$(basename "$dev")}"

                # Import disk: slot, partition, offset, size, erased, id
                if ! run_nmd_command "import $slot $(basename "$partition") 0 $size_kb 0 $id_to_use"; then
                    echo -e "${RED}Error: Failed to import disk to slot $slot${NC}"
                else
                    echo -e "${GREEN}Successfully imported disk to slot $slot${NC}"
                    assigned_slots+=("$slot")
                    assigned_count=$((assigned_count + 1))
                fi
                break
            fi
        done

        echo ""
    done

    # Check if any disks were assigned
    if [ "$assigned_count" -eq 0 ]; then
        echo -e "${YELLOW}No disks were assigned to the array.${NC}"
        return 0
    fi

    echo -e "${GREEN}Successfully assigned $assigned_count disk(s) to the array${NC}"

    # Now set the array label if provided
    if [ -n "$array_label" ]; then
        run_nmd_command "label $array_label"
    fi

    # Offer "parity is valid" option
    if [ "$do_new_config" -eq 1 ]; then
        echo ""
        echo "If you have done the new configuration in a very particular way, you can mark the parity valid for the new array."
        echo "This avoids parity reconstruction when starting the array."
        echo ""
        echo -e "Only do this if you are SURE the ${YELLOW}parity is already valid.${NC}"
        read -r -p "Is the array parity already valid? (y/N): " parity_valid
        if [[ "$parity_valid" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Marking parity valid for the next array start.${NC}"
            do_parity_skip=1
            local invalidslot="98"
            # mark Q valid only if it is still in the array
            if [[ " ${assigned_slots[*]} " =~ " 29 " ]]; then
                invalidslot="$invalidslot 99"
            else
                invalidslot="$invalidslot 29"
            fi
            if ! run_nmd_command "set invalidslot $invalidslot"; then
                echo -e "${RED}Error: Failed to mark parity valid${NC}"
                return 1
            fi
        else
            echo -e "${YELLOW}Parity will require reconstruction when the array is started.${NC}"
        fi
    fi

    # Show array status
    echo ""
    show_status

    # Ask if user wants to start the array now
    echo ""
    read -r -p "Do you want to start the array now? (y/N): " start_now
    if [[ "$start_now" =~ ^[Yy]$ ]]; then
        start_array
    else
        echo -e "${YELLOW}Array creation complete. You can start it with: ${GREEN}nmdctl start${NC}"
    fi
    # XXX: FIXME: driver internal state gets inconsistent after creating a new array
    # XXX: FIXME: need to reload the module to reset internal state
    echo ""
    echo -e "${YELLOW}Note: You may need to reload the module to reset the internal state"
    if [ "$do_parity_skip" -eq 1 ]; then
        echo -e "if after array start the array state is still DEGRADED.${NC}"
    else
        echo -e "if after parity reconstruction the array state is still DEGRADED.${NC}"
    fi
    echo -e "${YELLOW}Use: ${GREEN}nmdctl reload${NC}"
    return 0
}

# Add a new disk to the array
add_disk() {
    check_root

    # Check if module is loaded, will attempt to load if superblock provided
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists after loading the module
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check current array state
    local mdstate=$(get_nmdstat_value "mdState")

    if [ "$mdstate" = "STARTED" ]; then
        echo -e "${RED}Error: Array is currently running${NC}"
        echo -e "${YELLOW}Stop the array first with: ${GREEN}nmdctl stop${NC}"
        return 1
    fi

    if [ "$mdstate" = "NEW_ARRAY" ]; then
        echo -e "${RED}Error: Cannot add disk to a new array${NC}"
        echo -e "${YELLOW}Start the array first to build parity: ${GREEN}nmdctl start${NC}"
        return 1
    fi

    # Count the number of disks that have been imported
    local imported_disks=0
    local total_slots=$(get_defined_slots_count)
    for slot in $(get_defined_slots); do
        local rdevname=$(get_nmdstat_value "rdevName.$slot")
        if [ -n "$rdevname" ] && [ "$rdevname" != "none" ]; then
            imported_disks=$((imported_disks + 1))
        fi
    done

    if [ "$imported_disks" -lt "$total_slots" ]; then
        echo -e "${YELLOW}Warning: Not all disks have been imported ($imported_disks/$total_slots)${NC}"
        echo -e "${YELLOW}It's recommended to import all existing disks before adding a new one${NC}"
        read -rp "Continue anyway? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled."
            return 1
        fi
    fi

    # Check if we have any new disks already
    local mdnumnew=$(get_nmdstat_value "mdNumNew")
    if [ -n "$mdnumnew" ] && [ "$mdnumnew" -gt 0 ]; then
        echo -e "${RED}Error: Array already has a new disk added${NC}"
        echo -e "${YELLOW}The driver only supports adding one disk at a time.${NC}"
        echo -e "${YELLOW}Start the array to process the current new disk first: ${GREEN}nmdctl start${NC}"
        return 1
    fi

    echo -e "=== ${BLUE}Add New Disk to Array${NC} ==="
    echo ""
    echo -e "${YELLOW}This will add a single new disk to the array.${NC}"
    echo -e "${YELLOW}After adding the disk, you must start the array to process it.${NC}"
    echo -e "${YELLOW}Only devices with a single partition will be shown.${NC}"
    echo ""

    # Get available devices
    echo "Scanning for available disks..."
    local all_available_devices=($(list_available_devices))

    if [ ${#all_available_devices[@]} -eq 0 ]; then
        echo -e "${RED}Error: No suitable disk devices found${NC}"
        echo -e "${YELLOW}Make sure disks are connected and have a single partition${NC}"
        return 1
    fi

    # Get list of all disk IDs already in the array
    local array_disk_ids=()
    for slot in $(seq 0 29); do
        local disk_id=$(get_nmdstat_value "diskId.$slot")
        if [ -n "$disk_id" ] && [ "$disk_id" != "none" ]; then
            array_disk_ids+=("$disk_id")
        fi

        # Also check rdevId for newly added disks
        local rdev_id=$(get_nmdstat_value "rdevId.$slot")
        if [ -n "$rdev_id" ] && [ "$rdev_id" != "none" ]; then
            array_disk_ids+=("$rdev_id")
        fi
    done

    # Filter out disks that are already part of the array
    local available_devices=()
    local filtered_count=0

    for device_info in "${all_available_devices[@]}"; do
        IFS='|' read -r dev partition size_kb size_gb disk_id <<< "$device_info"
        local already_in_array=false

        # Skip if disk has no ID (unusual but possible)
        if [ -z "$disk_id" ]; then
            continue
        fi

        # Check if this disk ID is already in the array
        for array_id in "${array_disk_ids[@]}"; do
            # If the disk ID contains the array ID or vice versa, consider it a match
            if [[ "$disk_id" == *"$array_id"* ]] || [[ "$array_id" == *"$disk_id"* ]]; then
                already_in_array=true
                filtered_count=$((filtered_count + 1))
                break
            fi
        done

        # If not already in array, add to available devices
        if ! $already_in_array; then
            available_devices+=("$device_info")
        fi
    done

    if [ ${#available_devices[@]} -eq 0 ]; then
        echo -e "${RED}Error: No suitable disk devices found${NC}"
        if [ $filtered_count -gt 0 ]; then
            echo -e "${YELLOW}Found $filtered_count disk(s), but all are already part of the array${NC}"
        else
            echo -e "${YELLOW}Make sure disks are connected and have a single partition${NC}"
        fi
        return 1
    fi

    echo -e "Found ${GREEN}${#available_devices[@]}${NC} suitable devices with partitions"
    if [ $filtered_count -gt 0 ]; then
        echo -e "(Filtered out $filtered_count disk(s) that are already part of the array)"
    fi
    echo ""

    # Find available slots
    local used_slots=()
    local available_slots=()

    used_slots=($(get_defined_slots))

    # Then, determine which slots are available
    for slot in $(seq 1 28); do
        # shellcheck disable=SC2076
        if ! [[ " ${used_slots[*]} " =~ " $slot " ]]; then
            available_slots+=("$slot")
        fi
    done

    # Check if parity disks (slots 0 and 29) are used
    local has_parity=false
    local has_second_parity=false

    if [[ " ${used_slots[*]} " =~ " 0 " ]]; then
        has_parity=true
    fi

    if [[ " ${used_slots[*]} " =~ " 29 " ]]; then
        has_second_parity=true
    fi

    # If no parity disk, suggest adding that first
    if ! $has_parity; then
        available_slots+=("0")
        echo -e "${YELLOW}No parity disk found. Consider adding a parity disk (slot 0).${NC}"
    fi

    # If no second parity disk, suggest adding that as an option
    if ! $has_second_parity; then
        available_slots+=("29")
        echo -e "${YELLOW}No second parity disk found. You may add one (slot 29) for dual parity.${NC}"
    fi

    # Check if we have any available slots
    if [ ${#available_slots[@]} -eq 0 ]; then
        echo -e "${RED}Error: No available slots in the array${NC}"
        echo -e "${YELLOW}All possible slots are already assigned.${NC}"
        return 1
    fi

    echo -e "Available slots: ${GREEN}${available_slots[*]}${NC}"
    echo ""

    # Display information about slot types
    echo -e "${BLUE}Slot Types:${NC}"
    echo -e " - Slot 0: Primary parity disk"
    echo -e " - Slot 29: Secondary parity disk (for dual parity)"
    echo -e " - Slots 1-28: Data disks"
    echo ""

    # Select a single device
    local selected_device=""
    local selected_dev=""
    local selected_partition=""
    local selected_size_kb=0
    local selected_size_gb=0
    local selected_disk_id=""

    echo -e "Available devices:"
    echo ""
    echo -e "  #  Device      Size(GB)  ID"
    echo -e "  -  ----------  --------  ---------------------------------"

    local device_index=1
    for device_info in "${available_devices[@]}"; do
        IFS='|' read -r dev partition size_kb size_gb disk_id <<< "$device_info"

        # Show shortened disk ID for clarity
        local short_id="${disk_id}"
        if [ ${#short_id} -gt 25 ]; then
            short_id="${short_id:0:22}..."
        fi

        printf "  %-2d  %-10s  %-8s  %s\n" \
            "$device_index" \
            "$(basename "$dev")" \
            "$size_gb" \
            "$short_id"

        device_index=$((device_index + 1))
    done

    echo ""

    # Select device
    while true; do
        read -r -p "Enter device number to add (1-${#available_devices[@]}) or 'q' to quit: " choice

        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            echo "Operation cancelled."
            return 0
        fi

        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#available_devices[@]} ]; then
            echo -e "${RED}Invalid choice. Please enter a number between 1 and ${#available_devices[@]}.${NC}"
            continue
        fi

        selected_device="${available_devices[$((choice-1))]}"
        IFS='|' read -r selected_dev selected_partition selected_size_kb selected_size_gb selected_disk_id <<< "$selected_device"

        # Display selected disk details in the same format as create_array
        echo ""
        echo -e "=== Selected disk: ${BLUE}$(basename "$selected_dev")${NC} ==="
        echo -e "Partition: $(basename "$selected_partition")"
        echo -e "Size: $selected_size_gb GB"
        if [ -n "$selected_disk_id" ]; then
            echo -e "ID: $selected_disk_id"
        else
            echo -e "ID: Unknown"
        fi
        echo ""

        break
    done

    # Select slot
    local selected_slot=""
    while true; do
        echo -e "Enter slot assignment for this disk:"
        echo -e " P or 0: Parity disk"
        echo -e " Q or 29: Second parity disk (optional)"
        echo -e " 1-28: Data disk"
        echo -e " a: Abort adding disk"
        read -r -p "Choice: " choice

        if [ "$choice" = "a" ] || [ "$choice" = "A" ]; then
            echo "Operation cancelled."
            return 0
        fi

        # Convert P/Q to slot numbers
        case "$choice" in
            [Pp])
                choice="0"
                ;;
            [Qq])
                choice="29"
                ;;
        esac

        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}Invalid choice. Please enter a valid slot number or P/Q.${NC}"
            continue
        fi

        # Check if selected slot is available
        # shellcheck disable=SC2076
        if ! [[ " ${available_slots[*]} " =~ " $choice " ]]; then
            echo -e "${RED}Invalid slot. Please choose from available slots: ${available_slots[*]}.${NC}"
            continue
        fi

        selected_slot="$choice"
        break
    done

    # Format the slot name for display
    local slot_display="$selected_slot"
    if [ "$selected_slot" = "0" ]; then
        slot_display="P (0)"
    elif [ "$selected_slot" = "29" ]; then
        slot_display="Q (29)"
    fi

    echo -e "Selected slot: ${BLUE}$slot_display${NC}"
    echo ""

    # Confirm selection
    echo -e "You are about to add: ${BLUE}$(basename "$selected_dev")${NC} to slot ${BLUE}$slot_display${NC}"
    read -r -p "Proceed with adding this disk? (y/N): " confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Operation cancelled."
        return 0
    fi

    echo ""
    echo -e "Adding disk to array..."

    # Get disk ID (use device path if no ID)
    local id_to_use="${selected_disk_id:-$(basename "$selected_dev")}"

    # Import disk: slot, partition, offset, size, erased, id
    if ! run_nmd_command "import $selected_slot $(basename "$selected_partition") 0 $selected_size_kb 0 $id_to_use"; then
        echo -e "${RED}Error: Failed to add disk to slot $selected_slot${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully added disk to slot $selected_slot${NC}"
    echo ""

    # Show array status
    show_status

    echo ""
    echo -e "${YELLOW}To complete adding the disk, you need to:${NC}"
    echo -e "1. ${YELLOW}Start the array:${NC} ${GREEN}nmdctl start${NC}"
    if [ "$selected_slot" -eq 0 ] || [ "$selected_slot" -eq 29 ]; then
        echo -e "2. ${YELLOW}Reconstruct new parity: ${GREEN}nmdctl check${NC}"
    else
        echo -e "2. ${YELLOW}Clear the new data disk: ${GREEN}nmdctl check${NC}"
    fi
    echo -e "${YELLOW}Note: You cannot add another disk until this process completes.${NC}"

    return 0
}

# Unassign a disk from a specified slot
unassign_disk() {
    local slot="$1"

    # Check if we have a slot parameter
    if [ -z "$slot" ]; then
        echo -e "${RED}Error: Missing slot parameter${NC}"
        echo -e "Usage: ${YELLOW}nmdctl unassign SLOT${NC}"
        echo -e "Example: ${YELLOW}nmdctl unassign 1${NC} (to unassign disk from slot 1)"
        echo -e "Special slots: ${YELLOW}P${NC} or ${YELLOW}0${NC} (parity disk), ${YELLOW}Q${NC} or ${YELLOW}29${NC} (second parity)"
        return 1
    fi

    # Handle P/Q notation
    case "$slot" in
        [Pp])
            slot="0"
            ;;
        [Qq])
            slot="29"
            ;;
    esac

    # Validate slot is a number
    if ! [[ "$slot" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Error: Slot must be a number${NC}"
        return 1
    fi

    # Check if valid slot range (0-29)
    if [ "$slot" -lt 0 ] || [ "$slot" -gt 29 ]; then
        echo -e "${RED}Error: Invalid slot number. Valid slots are 0-29${NC}"
        return 1
    fi

    check_root

    # Check if module is loaded
    if ! check_module_loaded; then
        return 1
    fi

    # Check if /proc/nmdstat exists
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Check if array is stopped
    local mdstate=$(get_nmdstat_value "mdState")
    if [ "$mdstate" = "STARTED" ]; then
        echo -e "${RED}Error: Array must be stopped before unassigning disks${NC}"
        echo -e "Stop the array with: ${YELLOW}nmdctl stop${NC}"
        return 1
    fi

    # Get disk information for the slot
    local disk_id=$(get_nmdstat_value "diskId.$slot")
    local rdev_name=$(get_nmdstat_value "rdevName.$slot")
    local rdev_status=$(get_nmdstat_value "rdevStatus.$slot")
    local disk_size=$(get_nmdstat_value "diskSize.$slot")
    local rdev_size=$(get_nmdstat_value "rdevSize.$slot")
    local size_gb=0

    # Calculate size in GB if available
    if [ -n "$disk_size" ] && [ "$disk_size" -gt 0 ]; then
        size_gb=$(( (disk_size + 1048575) / 1048576 ))
    elif [ -n "$rdev_size" ] && [ "$rdev_size" -gt 0 ]; then
        size_gb=$(( (rdev_size + 1048575) / 1048576 ))
    fi

    # Check if the slot has a disk assigned
    if [ -z "$disk_id" ]; then
        echo -e "${RED}Error: No disk assigned to slot $slot${NC}"
        return 1
    fi

    # Format the slot name for display
    local slot_display="$slot"
    if [ "$slot" = "0" ]; then
        slot_display="P (0)"
    elif [ "$slot" = "29" ]; then
        slot_display="Q (29)"
    fi

    # Display slot information
    echo -e "=== Disk in Slot ${BLUE}$slot_display${NC} ==="
    echo -e "Disk ID      : $disk_id"
    if [ -n "$rdev_name" ] && [ "$rdev_name" != "none" ]; then
        echo -e "Device       : $rdev_name"
    else
        echo -e "Device       : ${YELLOW}Not imported${NC}"
    fi
    echo -e "Status       : $(format_disk_status "$rdev_status")"
    echo -e "Size         : $size_gb GB"
    echo ""

    # Warn about potential data loss
    echo -e "${RED}WARNING: Unassigning this disk will remove it from the array.${NC}"
    if [ "$slot" = "0" ] || [ "$slot" = "29" ]; then
        echo -e "${RED}This is a PARITY disk. Unassigning it will remove parity protection.${NC}"
    else
        echo -e "${RED}This is a DATA disk. Unassigning it will cause its contents to be emulated via parity (if available).${NC}"
    fi
    echo ""

    # Ask for confirmation
    read -r -p "Are you sure you want to unassign this disk? (y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Operation cancelled."
        return 1
    fi

    echo ""
    echo -e "Unassigning disk from slot $slot_display..."

    # Unassign the disk by importing an empty device
    if ! run_nmd_command "import $slot '' 0 0 0 ''"; then
        echo -e "${RED}Error: Failed to unassign disk from slot $slot${NC}"
        return 1
    fi

    echo -e "${GREEN}Successfully unassigned disk from slot $slot_display${NC}"
    echo ""

    # Show array status
    show_status

    return 0
}

# Reload nonraid module with superblock
reload_module() {
    local quiet_mode="${1:-0}"
    check_root

    # Get current superblock path
    local superblock=""

    # If --super wasn't provided, try to get the current superblock path from nmdstat
    if [ -z "$SUPERBLOCK_PATH" ] && [ -f /proc/nmdstat ]; then
        local current_superblock=$(get_nmdstat_value "sbName")
        if [ -n "$current_superblock" ] && [ "$current_superblock" != "(null)" ]; then
            superblock="$current_superblock"
            echo -e "Using current superblock from running module: ${GREEN}$superblock${NC}"
        else
            superblock="$DEFAULT_SUPERBLOCK"
        fi
    else
        superblock="${SUPERBLOCK_PATH:-$DEFAULT_SUPERBLOCK}"
    fi

    # Check if superblock file exists, but allow non-existent files for creating new arrays
    if [ ! -f "$superblock" ]; then
        if [ "$quiet_mode" -eq 0 ]; then
            echo -e "${YELLOW}Warning: Superblock file not found: $superblock${NC}"
            echo -e "${YELLOW}This will create a new superblock when the array is started.${NC}"

            # Ask for confirmation if creating a new superblock
            read -r -p "Continue with a new superblock? (y/N): " confirm
            if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
                echo "Operation cancelled."
                return 1
            fi
            echo -e "Proceeding with new superblock at: ${GREEN}$superblock${NC}"
        fi
    fi

    # Check if module is loaded
    if ! lsmod | grep -q nonraid; then
        if [ "$quiet_mode" -eq 0 ]; then
            echo -e "${YELLOW}NonRAID module not loaded. Loading with superblock: $superblock${NC}"
        fi
        if ! modprobe nonraid super="$superblock"; then
            echo -e "${RED}Error: Failed to load nonraid module${NC}"
            return 1
        fi
        if [ "$quiet_mode" -eq 0 ]; then
            echo -e "${GREEN}Successfully loaded nonraid module${NC}"
        fi
        return 0
    fi

    if [ "$quiet_mode" -eq 0 ]; then
        echo -e "${YELLOW}Stopping array and reloading nonraid module...${NC}"
    fi

    # Stop array if it's running
    local mdstate=""
    if [ -f /proc/nmdstat ]; then
        mdstate=$(get_nmdstat_value "mdState")
        if [ "$mdstate" = "STARTED" ]; then
            if [ "$quiet_mode" -eq 0 ]; then
                echo "Stopping array first..."
            fi
            if ! run_nmd_command "stop"; then
                echo -e "${RED}Error: Failed to stop array. Cannot safely reload module.${NC}"
                return 1
            fi
            if [ "$quiet_mode" -eq 0 ]; then
                echo -e "Array stopped successfully."
            fi
        fi
    fi

    # Unload module
    if [ "$quiet_mode" -eq 0 ]; then
        echo "Unloading nonraid module..."
    fi
    if ! modprobe -r nonraid; then
        echo -e "${RED}Error: Failed to unload nonraid module. It may be in use.${NC}"
        return 1
    fi

    # Small delay to ensure module is fully unloaded
    sleep 1

    # Load module with specified superblock
    if [ "$quiet_mode" -eq 0 ]; then
        echo "Loading nonraid module with superblock: $superblock"
    fi
    if ! modprobe nonraid super="$superblock"; then
        echo -e "${RED}Error: Failed to reload nonraid module${NC}"
        return 1
    fi

    if [ "$quiet_mode" -eq 0 ]; then
        echo -e "${GREEN}Successfully reloaded nonraid module with superblock: $superblock${NC}"
    fi
    return 0
}

# Mount all active data disks with identified filesystems
mount_array_disks() {
    check_root

    local mount_prefix="${1:-/mnt/disk}"

    # Check if array is running
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Get all values from nmdstat
    get_all_nmdstat_values NMDSTAT_VALUES

    local mdstate="${NMDSTAT_VALUES[mdState]}"
    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${RED}Error: Array must be started before mounting disks${NC}"
        echo -e "Current array state: $mdstate"
        echo -e "Start the array with: ${YELLOW}nmdctl start${NC}"
        return 1
    fi

    echo "=== Mounting NonRAID Array Disks ==="
    echo ""
    echo "Using mount prefix: $mount_prefix"
    echo ""

    local mounted_count=0
    local skipped_count=0
    local error_count=0

    # Get all defined slots
    local defined_slots=$(get_defined_slots)

    # Process data disks (skip parity slots 0 and 29)
    for slot in $defined_slots; do
        # Skip parity disks (slots 0 and 29)
        if [ "$slot" = "0" ] || [ "$slot" = "29" ]; then
            continue
        fi

        local rdevname="${NMDSTAT_VALUES[rdevName.$slot]}"
        local rdevstatus="${NMDSTAT_VALUES[rdevStatus.$slot]}"
        local diskname="${NMDSTAT_VALUES[diskName.$slot]}"
        local diskid="${NMDSTAT_VALUES[diskId.$slot]}"

        # Skip slots with no device or not in DISK_OK status
        if [ -z "$rdevname" ] || [ "$rdevname" = "none" ] || [ "$rdevstatus" != "DISK_OK" ]; then
            continue
        fi

        # Get filesystem type and current mountpoint
        local device="/dev/${diskname}"
        local fs_type=$(get_fs_type "$device")
        local current_mountpoint=$(get_mountpoint "$diskname" "$fs_type")

        # Skip if no filesystem or already mounted
        if [ -z "$fs_type" ] || [ "$fs_type" = "unknown" ]; then
            echo -e "Slot $slot (${YELLOW}${diskname}${NC}): ${YELLOW}No filesystem detected${NC}"
            skipped_count=$((skipped_count + 1))
            continue
        elif [ "$current_mountpoint" != "unmounted" ]; then
            echo -e "Slot $slot (${BLUE}${diskname}${NC}): Already mounted at ${GREEN}$current_mountpoint${NC}"
            skipped_count=$((skipped_count + 1))
            continue
        fi

        if [ "$fs_type" = "luks" ]; then
            if [ -z "$LUKS_KEYFILE" ] || [ ! -f "$LUKS_KEYFILE" ]; then
                echo -e "${RED}Error: LUKS device detected in slot $slot (${diskname}) but keyfile '${LUKS_KEYFILE}' does not exist. Cannot open LUKS device.${NC}"
                error_count=$((error_count + 1))
                continue
            fi
            # Open LUKS device
            echo -n "Slot $slot (${diskname}): Opening LUKS device... "
            if cryptsetup luksOpen --key-file "$LUKS_KEYFILE" "$device" "$diskname" >/dev/null 2>&1; then
                echo -e "${GREEN}SUCCESS${NC}"
                # redetect layered filesystem type after opening LUKS
                fs_type="$(get_fs_type "$device")"
            else
                echo -e "${RED}FAILED${NC}"
                error_count=$((error_count + 1))
                continue
            fi
        fi
        # Opened luks device, mount the filesystem
        if [[ "$fs_type" =~ ^luks\+.* ]]; then
            fs_type=$(echo "$fs_type" | cut -d'+' -f2)
            device="/dev/mapper/$diskname"
        fi

        # Handle mounting based on filesystem type
        case "$fs_type" in
            "zfs")
                # For ZFS, we need to import the pool
                local pool_name="disk${slot}"
                echo -n "Slot $slot (${diskname}): Importing ZFS pool $pool_name... "

                if zpool import -o cachefile=none -d "$device" "$pool_name" 2>/dev/null; then
                    echo -e "${GREEN}SUCCESS${NC}"
                    mounted_count=$((mounted_count + 1))
                else
                    echo -e "${RED}FAILED${NC}"
                    error_count=$((error_count + 1))
                fi
                ;;

            "xfs"|"ext4"|"ext3"|"ext2"|"btrfs"|*)
                # Standard filesystems
                local mountpoint="${mount_prefix}${slot}"

                # Create mountpoint if it doesn't exist
                if [ ! -d "$mountpoint" ]; then
                    mkdir -p "$mountpoint"
                fi

                echo -n "Slot $slot (${diskname}): Mounting ${fs_type^^} to $mountpoint... "

                if mount "$device" "$mountpoint" 2>/dev/null; then
                    echo -e "${GREEN}SUCCESS${NC}"
                    mounted_count=$((mounted_count + 1))
                else
                    echo -e "${RED}FAILED${NC}"
                    error_count=$((error_count + 1))
                fi
                ;;
        esac
    done

    echo ""
    echo "Mount summary:"
    echo -e "  ${GREEN}$mounted_count${NC} disks mounted successfully"
    echo -e "  ${BLUE}$skipped_count${NC} disks skipped (already mounted or no filesystem)"
    if [ $error_count -gt 0 ]; then
        echo -e "  ${RED}$error_count${NC} disks failed to mount"
        return 1
    fi

    return 0
}

# Unmount all active data disks
unmount_array_disks() {
    check_root

    # Check if array is running
    if ! check_nmdstat_exists; then
        return 1
    fi

    # Get all values from nmdstat
    get_all_nmdstat_values NMDSTAT_VALUES

    local mdstate="${NMDSTAT_VALUES[mdState]}"
    if [ "$mdstate" != "STARTED" ]; then
        echo -e "${RED}Error: Array must be started to unmount disks${NC}"
        echo -e "Current array state: $mdstate"
        return 1
    fi

    echo "=== Unmounting NonRAID Array Disks ==="
    echo ""

    local unmounted_count=0
    local skipped_count=0
    local error_count=0

    # Get all defined slots
    local defined_slots=$(get_defined_slots)

    # Process data disks (skip parity slots 0 and 29)
    for slot in $defined_slots; do
        # Skip parity disks (slots 0 and 29)
        if [ "$slot" = "0" ] || [ "$slot" = "29" ]; then
            continue
        fi

        local rdevname="${NMDSTAT_VALUES[rdevName.$slot]}"
        local rdevstatus="${NMDSTAT_VALUES[rdevStatus.$slot]}"
        local diskname="${NMDSTAT_VALUES[diskName.$slot]}"
        local diskid="${NMDSTAT_VALUES[diskId.$slot]}"

        # Skip slots with no device or not in DISK_OK status
        if [ -z "$rdevname" ] || [ "$rdevname" = "none" ] || [ "$rdevstatus" != "DISK_OK" ]; then
            continue
        fi

        # Get filesystem type and current mountpoint
        local device="/dev/${diskname}"
        local fs_type=$(get_fs_type "$device")
        local current_mountpoint=$(get_mountpoint "$diskname" "$fs_type")

        # Skip if no filesystem or already unmounted
        if [ -z "$fs_type" ] || [ "$fs_type" = "unknown" ]; then
            echo -e "Slot $slot (${YELLOW}${diskname}${NC}): ${YELLOW}No filesystem detected${NC}"
            skipped_count=$((skipped_count + 1))
            continue
        elif [ "$current_mountpoint" = "unmounted" ] && [[ ! "$fs_type" =~ ^luks\+.* ]]; then
            echo -e "Slot $slot (${BLUE}${diskname}${NC}): Already unmounted"
            skipped_count=$((skipped_count + 1))
            continue
        fi

        local luks_fs=0
        if [[ "$fs_type" =~ ^luks\+.* ]]; then
            fs_type=$(echo "$fs_type" | cut -d'+' -f2)
            luks_fs=1
        fi

        if [ "$current_mountpoint" != "unmounted" ]; then
            # Handle unmounting based on filesystem type
            case "$fs_type" in
                "zfs")
                    # For ZFS, we need to export the pool
                    # Get the pool name that contains this device
                    local pool_name=""
                    if command -v zpool >/dev/null 2>&1; then
                        pool_name=$(zpool list -H -o name,health | awk '{print $1}' | while read -r pool; do
                            if zpool status "$pool" 2>/dev/null | grep -q "$diskname"; then
                                echo "$pool"
                                break
                            fi
                        done)
                    fi

                    if [ -n "$pool_name" ]; then
                        echo -n "Slot $slot (${diskname}): Exporting ZFS pool $pool_name... "
                        if zpool export "$pool_name" 2>/dev/null; then
                            echo -e "${GREEN}SUCCESS${NC}"
                            unmounted_count=$((unmounted_count + 1))
                        else
                            echo -e "${RED}FAILED${NC}"
                            error_count=$((error_count + 1))
                        fi
                    else
                        echo -e "Slot $slot (${YELLOW}${diskname}${NC}): ${YELLOW}ZFS pool not found${NC}"
                        skipped_count=$((skipped_count + 1))
                    fi
                    ;;

                "xfs"|"ext4"|"ext3"|"ext2"|"btrfs"|*)
                    echo -n "Slot $slot (${diskname}): Unmounting ${fs_type^^} from $current_mountpoint... "

                    # Try unmounting with increasing force if needed
                    if umount "$current_mountpoint" 2>/dev/null ||
                    umount -f "$current_mountpoint" 2>/dev/null; then
                        echo -e "${GREEN}SUCCESS${NC}"
                        unmounted_count=$((unmounted_count + 1))
                    else
                        echo -e "${RED}FAILED${NC} (Device may be busy)"
                        error_count=$((error_count + 1))
                    fi
                    ;;
            esac
        fi

        # If it was a luks filesystem, close it
        if [ $luks_fs -eq 1 ]; then
            echo -n "Slot $slot (${diskname}): Closing LUKS device... "
            if cryptsetup luksClose "$diskname" 2>/dev/null; then
                echo -e "${GREEN}SUCCESS${NC}"
            else
                echo -e "${RED}FAILED${NC}"
                error_count=$((error_count + 1))
            fi
        fi
    done

    echo ""
    echo "Unmount summary:"
    echo -e "  ${GREEN}$unmounted_count${NC} disks unmounted successfully"
    echo -e "  ${BLUE}$skipped_count${NC} disks skipped (already unmounted or no filesystem)"
    if [ $error_count -gt 0 ]; then
        echo -e "  ${RED}$error_count${NC} disks failed to unmount"
        return 1
    fi

    return 0
}

# Main entry point
main() {
    # Check for at least one argument
    if [ $# -eq 0 ]; then
        usage
    fi

    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "-s"|"--super")
                if [ -z "$2" ] || [[ "$2" == -* ]]; then
                    echo -e "${RED}Error: --super requires a path argument${NC}"
                    usage
                fi
                SUPERBLOCK_PATH="$2"
                shift 2
                ;;
            "-k"|"--keyfile")
                if [ -z "$2" ] || [[ "$2" == -* ]]; then
                    echo -e "${RED}Error: --keyfile requires a path argument${NC}"
                    usage
                fi
                LUKS_KEYFILE="$2"
                shift 2
                ;;
            "-v"|"--verbose")
                VERBOSE=1
                shift
                ;;
            "-u"|"--unattended")
                UNATTENDED=1
                shift
                ;;
            "--no-color")
                RED=""
                GREEN=""
                BLUE=""
                YELLOW=""
                NC=""
                shift
                ;;
            "-h"|"--help"|"help")
                usage
                ;;
            *)
                # Not a global option, should be a command
                break
                ;;
        esac
    done

    # No command provided after global options
    if [ $# -eq 0 ]; then
        usage
    fi

    # Parse command
    local command="$1"
    shift

    case "$command" in
        "status")
            show_status
            ;;
        "create")
            create_array
            ;;
        "start")
            start_array
            ;;
        "stop")
            stop_array
            ;;
        "import")
            import_disks
            ;;
        "add")
            add_disk
            ;;
        "unassign")
            unassign_disk "$1"
            ;;
        "reload")
            reload_module
            ;;
        "check")
            start_check "$1"
            ;;
        "nocheck")
            stop_check "$1"
            ;;
        "mount")
            mount_array_disks "$1"
            ;;
        "unmount"|"umount")
            unmount_array_disks
            ;;
        *)
            echo -e "${RED}Error: Unknown command '$command'${NC}"
            usage
            ;;
    esac

    exit $?
}

# Run main function
main "$@"
